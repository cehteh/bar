#!/bin/bash
#shellcheck disable=SC2016

## BAsh Rules
##
## Adds a rule engine to bash.

# PLANNED: Autoinstall rules from global dir to local Barf.d
# PLANNED: parallel dependencies dep+
# PLANNED: load make style rules from a file?

function bar_main ## [Rulefile] [Rule [Arguments]] - loads a Barf file and executes a rule [MAIN] with optional arguments
{
    # shell sanity options
    set -euo pipefail
    # shellcheck disable=SC2155
    export LC_ALL=$(locale -a | grep -i 'C.utf.*8' || echo C)

    # shellcheck disable=SC2155
    declare -grx BAR_SELF="$(readlink "$BASH_ARGV0")"  ## bar itself
    declare -gx  BARF_DIR                  ## directory to load rules from
    declare -gx  BARF_FILE                 ## the Barf file used
    declare -gxr BAR_PWD="$PWD"            ## initial working directory
    declare -gxi BAR_VERBOSITY_LEVEL="${BAR_VERBOSITY_LEVEL:-2}"

    # bootstrap/load std_lib (which defines 'require')
    # shellcheck disable=SC1091
    find_barfd && source "$BARF_DIR/core_lib"
    # the std_lib and rule_lib are omnipresent other modules don't need to require it
    require std_lib rule_lib
    # load all modules with underscores in the name
    require '*_*'

    debug "using Barf directory: $BARF_DIR"
    [[ "$BARF_DIR" = "$BAR_PREFIX/share/bar/Barf.d" ]] && debug "I am the installed original bar"

    for BARF_FILE in "${1:-}" "Barf" "barf" ".Barf" ".barf"; do
        if [[ -f "$BARF_FILE" ]]; then
            debug "using: $BARF_FILE"
            [[ "$BARF_FILE" = "${1:-}" ]] && shift
            # shellcheck disable=SC1090 # dynamic source
            source "$BARF_FILE"
            break
        fi
    done

    local rc=0
    [[ -n "${1:-}" ]] && rule_autoload "$1"
    # shellcheck disable=2034
    BAR_RULES_SEALED=true
    trace "SEALING RULES"
    # shellcheck disable=SC2155
    declare -grix BAR_TIMESTAMP="$(bar_now)" ## Timestamp in microseconds since epoch of this invocation

    if rule_exists "${1:-MAIN}"; then
        rule_eval "${@:-MAIN}" || rc=$?
        if (( "$rc" == 0 )); then
            success "${@:-MAIN}"
        else
            failure "${@:-MAIN}"
        fi
        rule_exists CLEANUP && rule_eval CLEANUP
        return $rc
    else
        die "No Barf file found in current directory and no rule defined.

USAGE

  bar [Rulefile] [Rule [Arguments]]
or
  bar help
"
    fi
}

function find_barfd
{
    # TODO: introduce BAR_TOPLEVEL, walk tree upward not crossing fs borders unless BAR_CROSS_FS is set
    # TODO: BAR_TOPLEVEL must have Barf and Barf.d
    # TODO: only if no toplevel is found then use the prefix/shared/bar/Barf.d and no Barf

    for BARF_DIR in "$BAR_PWD/Barf.d" "$BAR_PWD/barf.d/" "$BAR_PWD/.Barf.d/" "$BAR_PWD/.barf.d/"; do
        if [[ -d "$BARF_DIR" ]]; then
            break
        fi
    done

    # shellcheck disable=2155
    local origin="$(command -v bar)"
    declare -gxr BAR_PREFIX="${origin%/bin/*}"

    if [[ ! -d "$BARF_DIR" ]]; then
        BARF_DIR="$BAR_PREFIX/share/bar/Barf.d"
        [[ -d "$BARF_DIR" ]] || die "Barf directory '$BARF_DIR' does not exist"
    fi
}


bar_main "$@"
