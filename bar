#!/bin/bash
# bar -- BAsh Rulez
#shellcheck disable=SC2016

## BAsh Rules
##
## Adds a rule engine to bash.

# PLANNED: Autoinstall rules from global dir to local Barf.d
# PLANNED: parallel dependencies dep+
# PLANNED: load make style rules from a file?

function bar_main ## [Rulefile] [Rule [Arguments]] - loads a Barf file and executes a rule [MAIN] with optional arguments
{
    # shell sanity options
    set -euo pipefail
    # shellcheck disable=SC2155
    export LC_ALL=$(locale -a | grep -i 'C.utf.*8' || echo C)

    # shellcheck disable=SC2155
    declare -grx BAR_SELF="$(readlink "$BASH_ARGV0")"  ## bar itself
    declare -gx  BARF_DIR                  ## directory to load rules from
    declare -gx  BARF_FILE                 ## the Barf file used
    declare -gxr BAR_PWD="$PWD"            ## initial working directory
    declare -gxi BAR_VERBOSITY_LEVEL="${BAR_VERBOSITY_LEVEL:-2}"

    # bootstrap/load std_lib (which defines 'require')
    # shellcheck disable=SC1091
    find_toplevel && source "$BARF_DIR/core_lib"
    debug "using Barf directory: $BARF_DIR"
    # the std_lib and rule_lib are omnipresent other modules don't need to require it
    require std_lib rule_lib
    # load all modules with underscores in the name
    require '*_*'

    local maybe_barf=
    local initial_rule=
    if called_as "*/bar" "*/.bar"; then
        maybe_barf="${1:-}"
    else
        initial_rule="${BASH_ARGV0##*/}"
    fi

    for BARF_FILE in "$maybe_barf" "Barf" "barf" ".Barf" ".barf"; do
        if [[ -f "$BARF_FILE" ]]; then
            debug "using: $BARF_FILE"
            [[ "$BARF_FILE" = "$maybe_barf" ]] && shift
            # shellcheck disable=SC1090 # dynamic source
            source "$BARF_FILE"
            break
        fi
    done

    local rc=0
    [[ -z "$initial_rule" && -n "${1:-}" ]] && rule_autoload "$1"
    # shellcheck disable=2034
    BAR_RULES_SEALED=true
    trace "SEALING RULES"
    # shellcheck disable=SC2155
    declare -grix BAR_TIMESTAMP="$(bar_now)" ## Timestamp in microseconds since epoch of this invocation

    [[ -z "${initial_rule}" ]] && {
        initial_rule="${1:-MAIN}"
        shift || true
    }

    if rule_exists "$initial_rule"; then
        rule_eval "$initial_rule" "$@" || rc=$?
        if (( "$rc" == 0 )); then
            success "$initial_rule" "$@"
        else
            failure "$initial_rule" "$@"
        fi
        rule_exists CLEANUP && rule_eval CLEANUP
        return $rc
    else
        die "No Barf file found in current directory and no rule defined.

USAGE

  bar [Rulefile] [Rule [Arguments]]
or
  bar help
"
    fi
}

function find_toplevel
{
    # shellcheck disable=2155
    local origin="$(command -v bar)"
    declare -gxr BAR_PREFIX="${origin%/bin/*}"
    declare -gx BAR_TOPLEVEL="$BAR_PWD"
    # shellcheck disable=2155
    local initial_fs_id="$(stat -f -c %i "$BAR_TOPLEVEL")"

    for BARF_DIR in "$BAR_TOPLEVEL/Barf.d" "$BAR_TOPLEVEL/barf.d/" "$BAR_TOPLEVEL/.Barf.d/" "$BAR_TOPLEVEL/.barf.d/"; do
        if [[ -d "$BARF_DIR" ]]; then
            readonly BAR_TOPLEVEL
            return 0
        fi
        if [[ "$BAR_TOPLEVEL" = "/" ]]; then
            break
        fi
        BAR_TOPLEVEL="$(readlink "$BAR_TOPLEVEL/..")"
        if [[ ! -v BAR_CROSS_FS && "$(stat -f -c %i "$BAR_TOPLEVEL")" != "$initial_fs_id" ]]; then
            break
        fi
    done
    warn "No Barf.d directory found, trying original/installed"

    if [[ ! -d "$BARF_DIR" ]]; then
        BARF_DIR="$BAR_PREFIX/share/bar/Barf.d"
        [[ -d "$BARF_DIR" ]] || die "Barf directory '$BARF_DIR' does not exist"
    fi
}

bar_main "$@"
