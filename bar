#!/bin/bash
# bar -- BAsh Rulez
#shellcheck disable=SC2016

## BAsh Rules
##
## Adds a rule engine to bash.

# PLANNED: Autoinstall rules from global dir to local Barf.d
# PLANNED: parallel dependencies dep+
# PLANNED: load make style rules from a file?

function bar_main ## [Rulefile] [Rule [Arguments]] - loads a Barf file and executes a rule [MAIN] with optional arguments
{
    trace "$*"
    # shell sanity options
    set -euo pipefail
    # shellcheck disable=SC2155
    export LC_ALL=$(locale -a | grep -i 'C.utf.*8' || echo C)

    # shellcheck disable=SC2155
    declare -grx BAR_SELF="$(realpath "$BASH_ARGV0")"  ## bar itself
    declare -grx BAR_CALLED_AS="${BASH_ARGV0##*/}"     ## called as name
    declare -gx  BAR_DIR                   ## directory to load rules from
    declare -gx  BARF_FILE                 ## the Barf file used
    declare -gxr BAR_PWD="$PWD"            ## initial working directory
    declare -gxi BAR_VERBOSITY_LEVEL="${BAR_VERBOSITY_LEVEL:-2}"
    declare -gA  BAR_REQUIRE_LOADED

    # bootstrap/load std_lib (which defines 'require')
    # shellcheck disable=SC1091
    find_toplevel
    debug "using Bar directory: $BAR_DIR"
    # the std_lib and rule_lib are omnipresent other modules don't need to require it
    require std_lib rule_lib
    # load all modules with underscores in the name
    require '*_*'

    local maybe_barf=
    local initial_rule=
    if [[ "$BAR_CALLED_AS" =~ \.?bar|please ]]; then
        maybe_barf="${1:-}"
    else
        initial_rule="$BAR_CALLED_AS"
    fi

    local barfs=("$BAR_TOPLEVEL/Barf" "$BAR_TOPLEVEL/barf" "$BAR_TOPLEVEL/.Barf" "$BAR_TOPLEVEL/.barf")
    if [[ "$BAR_CALLED_AS" = please ]]; then
        barfs=("Pleasef" "pleasef" ".Pleasef" ".pleasef" "$HOME/.Pleasef")
    fi

    for BARF_FILE in "$maybe_barf" "${barfs[@]}"; do
        if [[ -f "$BARF_FILE" ]]; then
            debug "using: $BARF_FILE"
            [[ "$BARF_FILE" = "$maybe_barf" ]] && shift
            # shellcheck disable=SC1090 # dynamic source
            source "$BARF_FILE"
            break
        fi
    done

    local rc=0
    [[ -z "$initial_rule" && -n "${1:-}" ]] && rule_autoload "$1"
    # shellcheck disable=SC2155
    declare -grix BAR_TIMESTAMP="$(bar_now)" ## Timestamp in microseconds since epoch of this invocation

    [[ -z "${initial_rule}" ]] && {
        initial_rule="${1:-MAIN}"
        shift || true
    }

    if rule_exists "$initial_rule"; then
        rule_exists SETUP && {
            rule_eval SETUP || die "SETUP failed" ;
        }
        rule_exists PREPROCESS && {
            rule_eval PREPROCESS || die "PREPROCESS failed" ;
        }

        rule_eval "$initial_rule" "$@" || rc=$?
        if (( "$rc" == 0 )); then
            success "$initial_rule" "$@"
            rule_exists POSTPROCESS && { rule_eval POSTPROCESS || error "POSTPROCCESS failed" ; }
        else
            failure "$initial_rule" "$@"
        fi

        rule_exists CLEANUP && { rule_eval CLEANUP || error "CLEANUP failed" ; }
        return $rc
    else
        die "No Barf/Pleasef file found in current directory and no rule defined.

USAGE

  bar [Rulefile] [Rule [Arguments]]
  please [Rulefile] [Rule [Arguments]]
or
  bar help
  please help
"
    fi
}

function find_toplevel
{
    # shellcheck disable=2155
    local origin="$(command -v bar)"
    declare -gxr BAR_PREFIX="${origin%/bin/*}"
    declare -gx BAR_TOPLEVEL="$BAR_PWD"
    # shellcheck disable=2155
    local initial_fs_id="$(stat -f -c %i "$BAR_TOPLEVEL")"

    local barfd=("$BAR_TOPLEVEL/Bar.d" "$BAR_TOPLEVEL/bar.d/" "$BAR_TOPLEVEL/.Bar.d/" "$BAR_TOPLEVEL/.bar.d/")
    if [[ "$BAR_CALLED_AS" = please ]]; then
        barfd=("$HOME/.config/please")
    fi

    for BAR_DIR in "${barfd[@]}"; do
        if [[ -d "$BAR_DIR" ]]; then
            readonly BAR_TOPLEVEL
            return 0
        fi
        if [[ "$BAR_TOPLEVEL" = "/" ]]; then
            break
        fi
        BAR_TOPLEVEL="$(readlink -f "$BAR_TOPLEVEL/..")"
        if [[ ! -v BAR_CROSS_FS && "$(stat -f -c %i "$BAR_TOPLEVEL")" != "$initial_fs_id" ]]; then
            break
        fi
    done

    warn "No Bar.d directory found, trying original/installed"

    if [[ ! -d "$BAR_DIR" ]]; then
        BAR_DIR="$BAR_PREFIX/share/bar/Bar.d"
        [[ -d "$BAR_DIR" ]] || die "Bar directory '$BAR_DIR' does not exist"
    fi
}

function source_info # [N] - returns file:line N (or 0) up the bash call stack
{
    echo "${BASH_SOURCE[$((${1:-0}+1))]}:${BASH_LINENO[$((${1:-0}))]}:${FUNCNAME[$((${1:-0}+1))]:+${FUNCNAME[$((${1:-0}+1))]}:}"
}

function require
{
    trace "$*"
    declare -i rc=0
    local try_load=""
    if [[ "$1" = "--try" ]]; then
        try_load=true
        shift
    fi
    local mod
    #shellcheck disable=2167,2165
    for mod in "$@"; do
        for mod in "$BAR_DIR/"$mod; do
            local modname="${mod##*/}"
            if [[ ! -v BAR_REQUIRE_LOADED["$modname"] ]]; then
                if [[ -f "$mod" ]]; then
                    debug "loading: $mod"
                    BAR_REQUIRE_LOADED["$modname"]=pending
                    # shellcheck disable=SC1090 # dynamic source
                    source "$mod" && BAR_REQUIRE_LOADED["$modname"]=true
                else
                    if [[ -z "$try_load" ]]; then
                        warn "failed loading: $mod"
                        rc=1
                    else
                        trace "failed try loading: $mod"
                    fi
                    BAR_REQUIRE_LOADED["$modname"]=false
                fi
            fi
        done
    done
    return $rc
}

function DBG ## [message..] - for print-style debugging, should not be present in production code
{
    echo -e "\033[1;37;41m  DBG:\033[0m $(source_info 1) $*" >&2
}

function die ## [message..] - prints 'message' to stderr and exits with failure
{
    if (( BAR_VERBOSITY_LEVEL > 0 )); then
        echo -e "\033[1;91mPANIC:\033[0m $(source_info 1) $*" >&2
    fi
    exit 1
}

function error ## [message..] - may print a error message to stderr and return failure
{
    if (( BAR_VERBOSITY_LEVEL > 0 )); then
        echo -e "\033[1;31mERROR:\033[0m $(source_info 1) $*" >&2
    fi
}

function warn ## [message..] - may print an warning to stderr
{
    if (( BAR_VERBOSITY_LEVEL > 1 )); then
        echo -e "\033[1;35m WARN:\033[0m $*" >&2
    fi
}

function note ## [message..] - may print an important notice to stderr
{
    if (( BAR_VERBOSITY_LEVEL > 2 )); then
        echo -e "\033[1;35m NOTE:\033[0m $*" >&2
    fi
}

function info ## [message..] - may print an informal message to stderr
{
    if (( BAR_VERBOSITY_LEVEL > 3 )); then
        echo -e "\033[1;34m INFO:\033[0m $*" >&2
    fi
}

function debug ## [message..] - may print a debug message to stderr
{
    if (( BAR_VERBOSITY_LEVEL > 4 )); then
        echo -e "\033[1;36mDEBUG:\033[0m $(source_info 1) $*" >&2
    fi
}

function trace ## [message] - may prints a trace message to stderr
{
    if (( BAR_VERBOSITY_LEVEL > 5 )); then
        echo -e "\033[1;96mTRACE:\033[0m $(source_info 1) $*" >&2
    fi
}

bar_main "$@"
