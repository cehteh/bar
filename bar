#!/bin/bash
#shellcheck disable=SC2016

## BAsh Rules
##
## Adds a rule engine to bash.

# PLANNED: Autoinstall rules from global dir to local Barf.d
# PLANNED: parallel dependencies dep+
# PLANNED: load make style rules from a file?

function bar_main ## [Rulefile] [Rule [Arguments]] - loads a Barf file and executes a rule [MAIN] with optional arguments
{
    # shell sanity options
    set -euo pipefail
    # shellcheck disable=SC2155
    export LC_ALL=$(locale -a | grep -i 'C.utf.*8' || echo C)

    # shellcheck disable=SC2155
    declare -grx BAR_SELF="$(readlink "$BASH_ARGV0")"  ## bar itself
    declare -gx  BARF_DIR                  ## directory to load rules from
    declare -gx  BARF_FILE                 ## the Barf file used
    # shellcheck disable=SC2155
    declare -grix BAR_TIMESTAMP="$(bar_now)" ## Timestamp in microseconds since epoch of this invocation
    declare -gxr BAR_PWD="$PWD"            ## initial working directory
    declare -gAx BAR_RULES                 ## discovered rules as name:"clauseidx.."
    declare -gAx BAR_RULES_RESULT          ## result "name args..":rc
    declare -g   BAR_RULES_SEALED          ## set to the last rule or 'true' when rules are sealed
    declare -g   BAR_CHECK_LEVEL=0         ## less alerting for check dependencies
    declare -gax BAR_CLAUSES=()            ## clause bodies enumerated
    declare -gax BAR_CLAUSE_DEPS=()        ## dependencies for each clause
    declare -gxi BAR_VERBOSITY_LEVEL="${BAR_VERBOSITY_LEVEL:-2}"

    for BARF_DIR in "$BAR_PWD/Barf.d" "$BAR_PWD/barf.d/" "$BAR_PWD/.Barf.d/" "$BAR_PWD/.barf.d/"; do
        if [[ -d "$BARF_DIR" ]]; then
            debug "using Barf directory: $BARF_DIR"
            break
        fi
    done

    if [[ ! -d "$BARF_DIR" ]]; then
        # shellcheck disable=2155
        local origin="$(command -v bar)"
        local prefix="${origin%/bin/*}"
        BARF_DIR="$prefix/share/bar/Barf.d"
        [[ -d "$BARF_DIR" ]] || die "Barf directory '$BARF_DIR' does not exist"
        debug "I am original bar '$origin'"
    fi

    require '*_*'
    for BARF_FILE in "${1:-}" "Barf" "barf" ".Barf" ".barf"; do
        if [[ -f "$BARF_FILE" ]]; then
            debug "using: $BARF_FILE"
            [[ "$BARF_FILE" = "${1:-}" ]] && shift
            # shellcheck disable=SC1090 # dynamic source
            source "$BARF_FILE"
            break
        fi
    done

    local rc=0
    [[ -n "${1:-}" ]] && rule_autoload "$1"
    BAR_RULES_SEALED=true
    if rule_exists "${1:-MAIN}"; then
        rule_eval "${@:-MAIN}" || rc=$?
        if (( "$rc" == 0 )); then
            success "${@:-MAIN}"
        else
            failure "${@:-MAIN}"
        fi
        rule_exists CLEANUP && rule_eval CLEANUP
        return $rc
    else
        die "No Barf file found in current directory and no rule defined.

USAGE

  bar [Rulefile] [Rule [Arguments]]
or
  bar help
"
    fi
}

function rule () ## [<name>:] [[!]dep[?] [arg]..].. [-- body..] - defines a rule
{
    trace "$*"
    local name="$1"
    if [[ "$name" = *: ]]; then
        name="${name%:}"
        shift
    else
        name=""
    fi

    local deps=()
    local has_body=
    local deps_for_cmd=
    while [[ $# -ne 0 ]]; do
        if [[ "$1" = - ]]; then
            shift
            deps_for_cmd=true
            break
        fi
        if [[ "$1" = -- ]]; then
            shift
            has_body=true
            break
        fi
        deps+=("$1")
        shift
    done

    # name given but no deps, no body, make body default to the rule name
    local body=""
    if [[ "${#deps[*]}" = 0 && "$#" == 0 && -n "$name" ]]; then
        body="$name "'"${RULE_ARGS[@]}"'
    elif [[ -n "$deps_for_cmd" && "$#" == 0 && -n "$name" ]]; then
        rule_exists "$name" && die "rule '$name' already defined"
        body="$name "'"${RULE_ARGS[@]}"'
    elif [[ -z "$name" ]]; then
        # default to MAIN when no rule name is given
        name="MAIN"
    fi

    if [[ -v BAR_RULES_SEALED ]]; then
        if [[ -v BAR_RULES[$name] && "$name" != "$BAR_RULES_SEALED" && "$name" != "CLEANUP" ]]; then
            die "Can not add clause '$name: ${deps//#/ }' after rules are sealed"
        else
            BAR_RULES_SEALED="$name"
        fi
    fi

    local ifs="$IFS"
    IFS=$'\n'
    BAR_CLAUSE_DEPS+=("${deps[*]}")
    IFS="$ifs"

    if [[ "$has_body" = true && $# = 0 ]]; then
        BAR_CLAUSES+=("$(cat)")
    else
        BAR_CLAUSES+=("$body$*")
    fi

    BAR_RULES["$name"]+=" $(( ${#BAR_CLAUSES[@]} - 1))"
}

function rule_delete
{
    trace "$*"
    local name="$1"
    if [[ -z "$name" ]]; then
        die "rule_delete requires a rule name"
    fi

    if ! rule_exists "$name"; then
        error "rule '$name' does not exist"
        return 1
    fi

    if [[ -n "$BAR_RULES_SEALED" ]]; then
        error "Can not delete rule '$name' after rules are sealed"
        return 1
    fi

    unset "BAR_RULES[$name]"
    unset "BAR_RULES_RESULT[$name]"
}

function rule_rename ## <oldname> <newname> - renames a rule
{
    trace "$*"
    local oldname="$1"
    local newname="$2"

    if [[ -z "$oldname" || -z "$newname" ]]; then
        die "rule_rename requires two rule names"
    fi

    if ! rule_exists "$oldname"; then
        error "rule '$oldname' does not exist"
        return 1
    fi

    if [[ -n "$BAR_RULES_SEALED" ]]; then
        error "Can not rename rule '$oldname' after rules are sealed"
        return 1
    fi

    BAR_RULES["$newname"]="${BAR_RULES[$oldname]}"
    unset "BAR_RULES[$oldname]"
    if [[ -v BAR_RULES_RESULT["$oldname"] ]]; then
        BAR_RULES_RESULT["$newname"]="${BAR_RULES_RESULT[$oldname]}"
        unset "BAR_RULES_RESULT[$oldname]"
    fi
}

function rule_eval ## <name> [args..]
{
    # shellcheck disable=2155
    local rule_id="$(hash_args "$PWD $*")"
    local name="$1"
    shift

    # shellcheck disable=2034
    local RULE_ARGS=("$@")
    rule_autoload "$name"

#    local rc

    if [[ ! "$name" = "always_"* && -v BAR_RULES_RESULT[$rule_id] ]]; then
        # rc="${BAR_RULES_RESULT[$rule_id]}"
        # if (( "$rc" == 0 )); then
        #     success "$name"
        # else
        #     failure "$name"
        # fi
        return "${BAR_RULES_RESULT[$rule_id]}"
    fi

    BAR_RULES_RESULT[$rule_id]="pending"

    local clause
    for clause in ${BAR_RULES[$name]}; do
        local skip=
        local dep
        local deps=()
        [[ "${#BAR_CLAUSE_DEPS[$clause]}" -gt 0 ]] && readarray -d $'\n' -t deps <<<"${BAR_CLAUSE_DEPS[$clause]}"

        local dep
        for dep in "${deps[@]}"; do
            local depname="${dep%% *}"
            declare -a depargs
            read -r -a depargs <<<"${dep:${#depname}+1}"
            local check=

            if [[ "$depname" = *"?" ]]; then
                check=true
                depname="${depname%?}"
            fi
            if [[ "$depname" = "!"* ]]; then
                check=negated
                depname="${depname:1}"
            fi
            if [[ "$depname" = *"~" ]]; then
                [[ -z "$check" ]] || die "~ can not be combined with ! or ?"
                check=unconditional
                depname="${depname%?}"
            fi
            [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL+1))

            # shellcheck disable=2155
            local dep_id="$(hash_args "$PWD $depname ${depargs[*]}")"
            local dep_rc="${BAR_RULES_RESULT[$dep_id]:-}"
            if [[ "$dep_id" = "always_"* || -z "$dep_rc" ]]; then
                dep_rc=0
                # shellcheck disable=2086
                rule_eval "$depname" "${depargs[@]}" || dep_rc=$?
            fi

            if [[ "$dep_rc" == pending ]]; then
                die "recursive rule $name: $depname"
            elif [[ "$check" = unconditional ]]; then
                uncond_call "$dep_rc" "$name: $depname~ ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                continue
            elif [[ "$dep_rc" == 0 && "$check" = negated ]]; then
                skip=true
                failure "$name: !$depname ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                break
            elif [[ "$dep_rc" != 0 ]]; then
                if [[ "$check" = true ]]; then
                    failure "$name: $depname? ${depargs[*]}"
                    skip=true
                    [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                    break
                elif [[ "$check" = negated ]]; then
                    success "$name: !$depname ${depargs[*]}"
                    [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                    continue
                fi
                # conclusive fail because of dep failure
                failure "$name: $depname ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                BAR_RULES_RESULT[$rule_id]="$dep_rc"
                return "$dep_rc"
            else
                if [[ "$check" = true ]]; then
                    success "$name: $depname? ${depargs[*]}"
                elif [[ "$check" = negated ]]; then
                    success "$name: !$depname ${depargs[*]}"
                else
                    success "$name: $depname ${depargs[*]}"
                fi
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
            fi
        done

        if [[ "$skip" != true ]]; then
            local rc=0
            eval "${BAR_CLAUSES[$clause]}" || rc=$?
            if [[ "$rc" != 0 ]]; then
                BAR_RULES_RESULT[$rule_id]=$rc
                return "$rc"
            fi
        fi
    done

    BAR_RULES_RESULT[$rule_id]=0
}

function rule_exists ## <name> - checks if a rule is defined
{
    [[ -v BAR_RULES[$1] ]]
}

function require
{
    trace "$*"
    declare -gA BAR_REQUIRED_MODULES
    local mod
    #shellcheck disable=2167,2165
    for mod in "$@"; do
        # TODO: for moddir in "$BAR_PWD/Barf.d/" "$BAR_PWD/barf.d/" "$BAR_PWD/.Barf.d/" "$BAR_PWD/.barf.d/"; do
        for mod in "$BARF_DIR/"$mod "$BAR_PWD/barf.d/"$mod "$BAR_PWD/.Barf.d/"$mod "$BAR_PWD/.barf.d/"$mod; do
            if [[ -z "${BAR_REQUIRED_MODULES[$mod]:-}" && -f "$mod" ]]; then
                trace "loading: $mod"
                # TODO: negative caching
                BAR_REQUIRED_MODULES["$mod"]=true
                # shellcheck disable=SC1090 # dynamic source
                source "$mod"
                # TODO: return 0  finally return 1
            fi
        done
    done
}

function rule_autoload ## <name>
{
    if ! rule_exists "$1"; then
        local modname="${1#always_}"
        modname="${modname#is_}"
        modname="${modname#has_}"
        modname="${modname%%_*}"
        require "$modname" || true

        # when $name exists as command or function then create a rule for that
        if ! rule_exists "$1" && command -v "$1" >/dev/null ; then
            rule "$1:"
        fi
        rule_exists "$1" || die "no rule, command or function '$1' defined"
    fi
}

function hash_args # - returns the sha1hash of all supplied args
{
    # shellcheck disable=SC2155
    local hash="$(sha1sum <<<"$*")"
    echo "${hash:0:40}"
}

function bar_now() ## - returns the current timestamp in microseconds since epoch
{
    echo "${EPOCHREALTIME//[^0-9]/}"
}

# TODO: statedb .Bar.s

# TODO: add [-s|--state "extrastate"]
function memo ## [-c|-d] [cmd args..].. - memoize the result/stdout/stderr of commands, will always return the same result again
{
    if [[ $1 == "-c" ]]; then
        unset MEMO_RC MEMO_STDOUT MEMO_STDERR
        shift
    fi

    local delete=false
    if [[ $1 == "-d" ]]; then
        delete=true
        shift
    fi

    declare -gAi MEMO_RC
    declare -gA MEMO_STDOUT MEMO_STDERR

    # shellcheck disable=SC2155
    local key="$(hash_args "$PWD $*")"

    if [[ $delete = true && -v MEMO_RC["$key"] ]]; then
        unset "MEMO_RC[$key]" "MEMO_STDOUT[$key]" "MEMO_STDERR[$key]"
    fi

    if [[ -v MEMO_RC["$key"] ]]; then
        echo -n "${MEMO_STDOUT[$key]}"
        echo -n "${MEMO_STDERR[$key]}" 1>&2
        return ${MEMO_RC["$key"]}
    elif [[ $# -ge 1 ]]; then
        local errexit=false
        [[ $- == *e* ]] && errexit=true
        set +e
        touch "/tmp/$key.stdout" "/tmp/$key.stderr"
        eval "$*" > >(tee "/tmp/$key.stdout") 2> >(tee "/tmp/$key.stderr" 1>&2)
        local rc=$?
        [[ $errexit = true ]] && set -e
        MEMO_RC["$key"]=$rc
        IFS= read -r -d '' MEMO_STDOUT["$key"] < "/tmp/$key.stdout"
        IFS= read -r -d '' MEMO_STDERR["$key"] < "/tmp/$key.stderr"
        rm "/tmp/$key.stdout" "/tmp/$key.stderr" 2>/dev/null
        return "$rc"
    fi
}

function memofn ## <functionnames..> - rewrites a function into a function that uses 'memo'
{
    for fn in "$@"; do
        # rename the original function as nomemo_*
        eval "nomemo_$(declare -f "$fn")"
        # create a new function that calls memo with the original function
        eval "function $fn () { memo nomemo_$fn \"\$@\" ; }"
    done
}

function source_info # [N] - returns file:line N (or 0) up the bash call stack
{
    echo "${BASH_SOURCE[$((${1:-0}+1))]}:${BASH_LINENO[$((${1:-0}))]}:${FUNCNAME[$((${1:-0}+1))]:+${FUNCNAME[$((${1:-0}+1))]}:}"
}

function die ## [message..] - prints 'message' to stderr and exits with failure
{
    if [[ "${BAR_VERBOSITY_LEVEL:-5}" -gt 0 ]]; then
        echo -e "\033[1;91mPANIC:\033[0m $(source_info 1) $*" >&2
    fi
    exit 1
}

function success ## [message..] -
{
    if (( BAR_CHECK_LEVEL > 0 )); then
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 2 )) && echo -e "\033[1;32mCHECK:\033[0m $*" >&2
    else
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 1 )) && echo -e "\033[1;32m   OK:\033[0m $*" >&2
    fi
}

function failure ## [message..] -
{
    if (( BAR_CHECK_LEVEL > 0 )); then
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 2 )) && echo -e "\033[1;90mCHECK: \033[9m$*\033[0m" >&2
    else
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 1 )) && echo -e "\033[1;31m FAIL:\033[0m $*" >&2
    fi
}

function uncond_call ## <rc> [message..] -
{
    declare -i rc="$1"
    shift
    if (( "${BAR_VERBOSITY_LEVEL:-5}" > 2 )); then
        if (( rc == 0 )); then
            echo -e "\033[1;32m EVAL:\033[0m $*" >&2
        else
            echo -e "\033[1;90m EVAL:\033[0m $*" >&2
        fi
    fi
}

function error ## [message..] - may print a error message to stderr and return failure
{
    # TODO: (( ))
    if [[ "${BAR_VERBOSITY_LEVEL:-5}" -gt 0 ]]; then
        echo -e "\033[1;31mERROR:\033[0m $(source_info 1) $*" >&2
    fi
}

function warn ## [message..] - may print an warning to stderr
{
    if [[ "${BAR_VERBOSITY_LEVEL:-5}" -gt 1 ]]; then
        echo -e "\033[1;35m WARN:\033[0m $*" >&2
    fi
}

function note ## [message..] - may print an important notice to stderr
{
    if [[ "${BAR_VERBOSITY_LEVEL:-5}" -gt 1 ]]; then
        echo -e "\033[1;35m NOTE:\033[0m $*" >&2
    fi
}

function info ## [message..] - may print an informal message to stderr
{
    if [[ "${BAR_VERBOSITY_LEVEL:-5}" -gt 3 ]]; then
        echo -e "\033[1;34m INFO:\033[0m $*" >&2
    fi
}

function debug ## [message..] - may print a debug message to stderr
{
    if [[ "${BAR_VERBOSITY_LEVEL:-5}" -gt 4 ]]; then
        echo -e "\033[1;36mDEBUG:\033[0m $(source_info 1) $*" >&2
    fi
}

function trace ## [message] - may prints a trace message to stderr
{
    if [[ "${BAR_VERBOSITY_LEVEL:-5}" -gt 5 ]]; then
        echo -e "\033[1;96mTRACE:\033[0m $(source_info 1) $*" >&2
    fi
}

bar_main "$@"
