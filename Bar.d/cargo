#!/bash
# shellcheck disable=2016

function is_cargo_tool_installed ## [+toolchain] <tool> [args..] - Checks if 'cargo <tool>' is installed
{
    declare -a toolpart
    # may be prefixed with a '+toolchain'
    if [[ "${1:0:1}" = "+" ]]; then
        toolpart=("$1" "$2")
        shift 2
    else
        toolpart=("$1")
        shift
    fi
    declare -a args
    if [[ "$#" -eq 0 ]]; then
        # when no args are given then default to '--version'
        args=("--version")
    else
        args=("$@")
    fi
    if cargo "${toolpart[@]}" "${args[@]}" &>/dev/null; then
        debug "cargo ${toolpart[*]} is installed"
        return 0
    else
        note "cargo ${toolpart[*]} is not installed"
        return 1
    fi
}

memofn is_cargo_tool_installed

function cargo_cache_artifacts
{
    if [[ -n "${TESTDIR_PREV:-}" ]] && lock_wait "$TESTDIR_PREV/.bar" ; then
        info "caching artifacts from $TESTDIR_PREV"
        if [[ -d "$TESTDIR_PREV/target" ]]; then
            cp -rluf "$TESTDIR_PREV/target" "./"
        else
            info "no $TESTDIR_PREV/target/ to copy from"
        fi
        # PLANNED:    export CARGO_NET_OFFLINE="true"
        lock_remove "$TESTDIR_PREV/.bar"
    else
        info "not populating /target cache"
    fi
}

rule cargo_lint: cargo_check cargo_clippy_strict cargo_fmt_check

rule cargo_build_unit_tests: \
     'cargo_test --lib --no-run --quiet' \
     'cargo_test --bins --no-run --quiet'
rule cargo_test_units: cargo_build_unit_tests \
     'cargo_test --lib --quiet' \
     'cargo_test --bins --quiet'

rule cargo_build_integration_tests: \
     'cargo_test --tests --no-run --quiet'

rule cargo_test_integrations: cargo_build_integration_tests \
     'cargo_test --tests --quiet' \
     'cargo_test --doc --quiet'

# --examples          Test all examples
# --benches           Test all targets that have `bench = true` set



# TODO: split into
# --lib               Test only this package's library
# --bins              Test all binaries
# --bin [<NAME>]      Test only the specified binary
# --examples          Test all examples
# --example [<NAME>]  Test only the specified example
# --tests             Test all targets that have `test = true` set
# --test [<NAME>]     Test only the specified test target
# --benches           Test all targets that have `bench = true` set
# --bench [<NAME>]    Test only the specified bench target
# --all-targets       Test all targets (does not include doctests)
# --doc               Test only this library's documentation




# rule test_doc: -- info "Testing documentation..."


# rule build_benches: is_cargo_project? 'cargo_build --benches'
# rule build_examples: is_cargo_project? 'cargo_build --examples'
# rule build_lib: is_cargo_project? 'cargo_build --lib'
# rule build_bin: is_cargo_project? 'cargo build --bins'
# rule build_doc: is_cargo_project? cargo_doc


# function cargo_test
# {
#     run_test cargo test "$@"
# }
# 
# rule cargo_test: is_cargo_project? -

require run

#rule cargo_build: -- cargo build "${RULE_ARGS[@]}"
function cargo_build
{
    run_test cargo build --workspace "$@"
}

function cargo_test
{
    run_test cargo test --workspace "$@"
}

function cargo_check
{
    run_test cargo check --workspace
}

function cargo_clippy_errors ## - Tests with 'cargo clippy' for errors only
{
    cargo clippy 2>&1 | tee /dev/stderr | awk '/error.*: /{exit 1}'
}

function cargo_clippy_strict ## - Test with 'cargo clippy' for warnings and errors
{
    cargo clippy 2>&1 | tee /dev/stderr | awk '/(warning|error).*: /{exit 1}'
}

function cargo_doc ## - builds docs, backgrounds, optional.
{
    export RUSTDOCFLAGS="-D rustdoc::broken_intra_doc_links"
    run_test cargo doc --workspace "$@"
}

#rule cargo_doc: 'cargo_tool_installed doc --help' -


rule cargo_audit: is_rust_project 'cargo_tool_installed? audit' -- cargo audit --color never -D warnings --stale --quiet
rule cargo_audit: is_rust_project '!cargo_tool_installed audit' -- warn "cargo audit is not installed"


# only allows cargo options (+toolchain etc) as argument
function cargo_fmt_check
{
    run_subcommand cargo fmt "$@" -- --all -- --check
}

