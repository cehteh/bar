#!/bash
# shellcheck disable=2016,2086

require run

export CARGO_TOOLCHAIN="${CARGO_TOOLCHAIN:-}"

function is_cargo_tool_installed ## [+toolchain] <tool> [args..] - Checks if 'cargo <tool>' is installed
{
    declare -a toolpart
    # may be prefixed with a '+toolchain'
    if [[ "${1:0:1}" = "+" ]]; then
        toolpart=("$1" "$2")
        shift 2
    else
        toolpart=("$1")
        shift
    fi
    declare -a args
    if [[ "$#" -eq 0 ]]; then
        # when no args are given then default to '--version'
        args=("--version")
    else
        args=("$@")
    fi
    if cargo "${toolpart[@]}" "${args[@]}" &>/dev/null; then
        debug "cargo ${toolpart[*]} is installed"
        return 0
    else
        note "cargo ${toolpart[*]} is not installed"
        return 1
    fi
}

memofn is_cargo_tool_installed

function is_cargo_toolchain_available ## [+toolchain] - Check if a toolchain is available
{
    if cargo "$1" --version &>/dev/null; then
        debug "toolchain $1 is installed"
        return 0
    else
        note "toolchain $1 is not installed"
        return 1
    fi
}

memofn is_cargo_toolchain_available

function cargo_cache_artifacts
{
    if [[ -n "${TESTDIR_PREV:-}" ]] && lock_wait "$TESTDIR_PREV/.bar" ; then
        info "caching artifacts from $TESTDIR_PREV"
        if [[ -d "$TESTDIR_PREV/target" ]]; then
            cp -rluf "$TESTDIR_PREV/target" "./"
        else
            info "no $TESTDIR_PREV/target/ to copy from"
        fi
        # PLANNED:    export CARGO_NET_OFFLINE="true"
        lock_remove "$TESTDIR_PREV/.bar"
    else
        info "not populating /target cache"
    fi
}

rule cargo_lint: cargo_check cargo_clippy_strict cargo_fmt_check

function cargo_toolchain
{
    is_cargo_toolchain_available "$1" || return 1
    clause_local "CARGO_TOOLCHAIN='$1'"
}

rule --meta cargo_toolchain:

function cargo_fmt_check
{
    # shellcheck disable=2153
    run_test cargo $CARGO_TOOLCHAIN fmt --all --check
}

rule cargo_fmt_check: --conclusive 'cargo_toolchain? +nightly' -
rule cargo_fmt_check: --conclusive -

rule cargo_build_unit_tests: \
     'cargo_test --lib --no-run --quiet' \
     'cargo_test --bins --no-run --quiet'
rule cargo_test_units: cargo_build_unit_tests \
     'cargo_test --lib --quiet' \
     'cargo_test --bins --quiet'

rule cargo_build_integration_tests: \
     'cargo_test --tests --no-run --quiet'

rule cargo_test_integrations: cargo_build_integration_tests \
     'cargo_test --tests --quiet' \
     'cargo_test --doc --quiet'

function cargo_fmt
{
    # shellcheck disable=2153
    run_test cargo $CARGO_TOOLCHAIN fmt --all
}

rule cargo_fmt: --conclusive 'cargo_toolchain? +nightly' -
rule cargo_fmt: --conclusive -

function cargo_fix
{
    # shellcheck disable=2153
    run_test cargo $CARGO_TOOLCHAIN fix --all --allow-dirty
}

function cargo_build
{
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" build --workspace "$@"
}

function cargo_test
{
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" test --workspace "$@"
}

function cargo_check
{
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" check --workspace
}

function cargo_clippy_errors ## - Tests with 'cargo clippy' for errors only
{
    cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" clippy 2>&1 | tee /dev/stderr | awk '/error.*: /{exit 1}'
}

function cargo_clippy_strict ## - Test with 'cargo clippy' for warnings and errors
{
    cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" clippy 2>&1 | tee /dev/stderr | awk '/(warning|error).*: /{exit 1}'
}

function cargo_doc
{
    export RUSTDOCFLAGS="-D rustdoc::broken_intra_doc_links"
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" doc --workspace "$@"
}

function cargo_update
{
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" update --recursive
}

function cargo_has_unsafe_code ## - Checks if the source use 'unsafe'
{
    # this does only a coarse check, but depends not on external tools
    if cargo rustc -- --emit=metadata -Funsafe-code &>/dev/null; then
        debug "no unsafe used"
        return 1
    else
        debug "unsafe used"
        return 0
    fi
}

function cargo_miri
{
    run_test cargo +nightly miri test
}

rule cargo_miri: cargo_has_unsafe_code? 'cargo_toolchain +nightly' -

function cargo_check_msrv
{
    run_test --timeout 300 cargo msrv --bisect --ignore-lockfile verify
}

rule cargo_check_msrv: --conclusive 'is_cargo_tool_installed? msrv' -
rule cargo_check_msrv: --conclusive '!is_cargo_tool_installed msrv' -- warn "cargo msrv is not installed"

function cargo_mutants
{
    cargo mutants --colors "${COLOR:-auto}" -j $(( $( nproc || echo 8 ) / 4 )) -t 300 --baseline skip
}

rule cargo_mutants: --conclusive 'is_cargo_tool_installed? mutants' cargo_test_units cargo_test_integrations -
rule cargo_mutants: --conclusive '!is_cargo_tool_installed mutants' -- warn "cargo mutants is not installed"

function cargo_outdated
{
    cargo outdated --color "${COLOR:-auto}" --quiet --exit-code 1
}

rule cargo_outdated: --conclusive 'is_cargo_tool_installed? outdated' -
rule cargo_outdated: --conclusive '!is_cargo_tool_installed outdated' -- warn "cargo outdated is not installed"

function cargo_audit
{
    cargo audit --color "${COLOR:-auto}" -D warnings --stale --quiet
}

rule cargo_audit: --conclusive 'is_cargo_tool_installed? audit' -
rule cargo_audit: --conclusive '!is_cargo_tool_installed audit' -- warn "cargo audit is not installed"

function cargo_bench
{
    cargo --color "${COLOR:-auto}" bench
}
