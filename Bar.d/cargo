#!/bash
# shellcheck disable=2016,2086

### Rust/cargo support.

# prototype: "toolchain" = "ext cargo_toolchain_complete"
# prototype: "tool" = "ext cargo_tool_complete"
# prototype: "buildargs" = "extcomp cargo ${CARGO_TOOLCHAIN} build --workspace"
# prototype: "testargs" = "extcomp cargo ${CARGO_TOOLCHAIN} test --workspace"
# prototype: "docargs" = "extcomp cargo ${CARGO_TOOLCHAIN} doc --workspace"
# prototype: "miriargs" = "extcomp cargo +nightly miri test"

require run

declare -xg CARGO_TOOLCHAIN="${CARGO_TOOLCHAIN:-}" ## The rust toolchain that is used for most operations.

function is_cargo_tool_installed ## [+toolchain] <tool> [args..] - Checks if 'cargo <tool>' is installed
{
    ## When [args..] is not present then '--version' is used. Tools that do not handle
    ## '--version' need 'args..' to give some sensible result.
    declare -a toolpart
    # may be prefixed with a '+toolchain'
    if [[ "${1:0:1}" = "+" ]]; then
        toolpart=("$1" "$2")
        shift 2
    else
        toolpart=("$1")
        shift
    fi
    declare -a args
    if [[ "$#" -eq 0 ]]; then
        # when no args are given then default to '--version'
        args=("--version")
    else
        args=("$@")
    fi
    if cargo "${toolpart[@]}" "${args[@]}" &>/dev/null; then
        debug "cargo ${toolpart[*]} is installed"
        return 0
    else
        note "cargo ${toolpart[*]} is not installed"
        return 1
    fi
}

memofn is_cargo_tool_installed

function is_cargo_toolchain_available ## [+toolchain] - Check if a toolchain is available
{
    if cargo "$1" --version &>/dev/null; then
        debug "toolchain $1 is installed"
        return 0
    else
        note "toolchain $1 is not installed"
        return 1
    fi
}

memofn is_cargo_toolchain_available

function cargo_toolchain_complete ## List available cargo toolchains for completion
{
    ## This function is called by bar_complete to provide completions for +toolchain parameters.
    ## It lists installed Rust toolchains using rustup.
    if command -v rustup &>/dev/null; then
        rustup toolchain list 2>/dev/null | sed 's/[[:space:]].*$//' | sed 's/^/+/'
    fi
}

function cargo_tool_complete ## List available cargo tools/subcommands for completion
{
    ## This function provides completion for cargo tool names (subcommands).
    ## It lists both built-in cargo commands and installed extensions.
    cargo --list 2>/dev/null | awk '/^    [a-z]/{print $1}' | grep -v '^[[:space:]]*$'
}

function cargo_cargo_complete ## Generic cargo completion that forwards to cargo's bash completion
{
    ## This function provides intelligent completion for cargo commands by invoking
    ## cargo's native bash completion function as a black box.
    ## Usage: Called by completion system with current word to complete
    
    # Check if we can use cargo's completion
    if ! command -v rustc >/dev/null 2>&1; then
        # Fallback to file completion
        compgen -f -- "${1:-}"
        return
    fi
    
    local cargo_completion
    cargo_completion="$(rustc --print sysroot)/etc/bash_completion.d/cargo"
    if [[ ! -f "$cargo_completion" ]]; then
        # Fallback to file completion
        compgen -f -- "${1:-}"
        return
    fi
    
    # Source bash-completion helpers if available
    if [[ ! $(type -t _get_comp_words_by_ref) == function ]]; then
        if [[ -f /usr/share/bash-completion/bash_completion ]]; then
            source /usr/share/bash-completion/bash_completion 2>/dev/null || true
        elif [[ -f /etc/bash_completion ]]; then
            source /etc/bash_completion 2>/dev/null || true
        fi
    fi
    
    # Source cargo completion if not already loaded
    if [[ ! $(type -t _cargo) == function ]]; then
        source "$cargo_completion" 2>/dev/null || {
            compgen -f -- "${1:-}"
            return
        }
    fi
    
    # Set up completion environment
    # We need to simulate being at the right position in the command line
    local cur="${1:-}"
    
    # Build COMP_WORDS from CARGO_TOOLCHAIN and current context
    local -a comp_words=(cargo)
    [[ -n "${CARGO_TOOLCHAIN}" ]] && comp_words+=("${CARGO_TOOLCHAIN}")
    
    # Add any additional context from the calling environment
    # For now, just add the current word
    comp_words+=("$cur")
    
    COMP_WORDS=("${comp_words[@]}")
    COMP_CWORD=$((${#COMP_WORDS[@]} - 1))
    COMP_LINE="${COMP_WORDS[*]}"
    COMP_POINT=${#COMP_LINE}
    COMPREPLY=()
    
    # Call cargo's completion function
    _cargo 2>/dev/null || true
    
    # Filter results by current prefix
    if [[ -n "$cur" ]]; then
        printf '%s\n' "${COMPREPLY[@]}" | grep "^${cur}"
    else
        printf '%s\n' "${COMPREPLY[@]}"
    fi
}


function cargo_cache_artifacts
{
    if [[ -n "${TESTDIR_PREV:-}" ]] && lock_wait "$TESTDIR_PREV/.bar" ; then
        info "caching artifacts from $TESTDIR_PREV"
        if [[ -d "$TESTDIR_PREV/target" ]]; then
            cp -rluf "$TESTDIR_PREV/target" "./"
        else
            info "no $TESTDIR_PREV/target/ to copy from"
        fi
        # PLANNED:    export CARGO_NET_OFFLINE="true"
        lock_remove "$TESTDIR_PREV/.bar"
    else
        info "not populating /target cache"
    fi
}

## Runs all linters
rule cargo_lint: cargo_check cargo_clippy_strict cargo_fmt_check

function cargo_toolchain
{
    is_cargo_toolchain_available "$1" || return 1
    clause_local "CARGO_TOOLCHAIN='$1'"
}

## <+toolchain> - Clause local change of the toochain used by cargo.
rule --meta cargo_toolchain:

function cargo_fmt_check
{
    # shellcheck disable=2153
    run_test cargo $CARGO_TOOLCHAIN fmt --all --check
}

## Checks whenever the source code is well formatted.
## If available the '+nightly' toolchain is used.
rule cargo_fmt_check: --conclusive 'cargo_toolchain? +nightly' -
rule cargo_fmt_check: --conclusive -

## Builds unit tests.
rule cargo_build_unit_tests: \
     'cargo_test --lib --no-run --quiet' \
     'cargo_test --bins --no-run --quiet'
## Runs unit tests.
rule cargo_test_units: cargo_build_unit_tests \
     'cargo_test --lib --quiet' \
     'cargo_test --bins --quiet'

## Build integration tests
rule cargo_build_integration_tests: \
     'cargo_test --tests --no-run --quiet'

## Run integration tests. This includes the doctests.
rule cargo_test_integrations: cargo_build_integration_tests \
     'cargo_test --tests --quiet' \
     'cargo_test --doc --quiet'

function cargo_fmt
{
    # shellcheck disable=2153
    run_test cargo $CARGO_TOOLCHAIN fmt --all
}

## Run 'cargo fmt'. When available the '+nightly' toolchain is used.
## Note that this will modify the source in place.
rule cargo_fmt: --conclusive 'cargo_toolchain? +nightly' -
rule cargo_fmt: --conclusive -

function cargo_fix ## Run 'cargo fix'.
{
    ## Note that this will modify the source in place.
    # shellcheck disable=2153
    run_test cargo $CARGO_TOOLCHAIN fix --all --allow-dirty
}

function cargo_build ## [buildargs..] - Compile a local package and all of its dependencies
{
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" build --workspace "$@"
}

function cargo_test ## [testargs..] - Execute all unit and integration tests
{
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" test --workspace "$@"
}

function cargo_check ## Run 'cargo check'. Testing whenever the source can be compiled.
{
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" check --workspace
}

function cargo_clippy_errors ## Tests with 'cargo clippy' for errors only
{
    cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" clippy 2>&1 | tee /dev/stderr | awk '/error.*: /{exit 1}'
}

function cargo_clippy_strict ## Test with 'cargo clippy' for warnings and errors
{
    cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" clippy 2>&1 | tee /dev/stderr | awk '/(warning|error).*: /{exit 1}'
}

function cargo_doc ## [docargs..] - Build this package's and its dependencies' documentation
{
    export RUSTDOCFLAGS="-D rustdoc::broken_intra_doc_links"
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" doc --workspace "$@"
}

function cargo_update ## Run 'cargo update'
{
    run_test cargo $CARGO_TOOLCHAIN --color "${COLOR:-auto}" update --recursive
}

function cargo_has_unsafe_code ## Checks if the source use 'unsafe' code.
{
    ## This does only a coarse '-Funsafe-code' check, but does not depend on external tools.
    if cargo rustc -- --emit=metadata -Funsafe-code &>/dev/null; then
        debug "no unsafe used"
        return 1
    else
        debug "unsafe used"
        return 0
    fi
}

function cargo_miri ## [miriargs..] - Run tests under miri (memory sanitizer)
{
    run_test cargo +nightly miri test "$@"
}

## When there is unsafe code then run a test under miri supervision.
## Requires the '+nightly' toolchain.
rule cargo_miri: cargo_has_unsafe_code? 'cargo_toolchain +nightly' -

function cargo_check_msrv
{
    run_test --timeout 300 cargo msrv --bisect --ignore-lockfile verify
}

## Checks whenever the 'rust_version' in the manifest is sufficient.
## This check only happens when 'cargo-msrv' is installed, otherwise a warning is printed.
rule cargo_check_msrv: --conclusive 'is_cargo_tool_installed? msrv' -
rule cargo_check_msrv: --conclusive '!is_cargo_tool_installed msrv' -- warn "cargo msrv is not installed"

function cargo_mutants
{
    cargo mutants --colors "${COLOR:-auto}" -j $(( $( nproc || echo 8 ) / 4 )) -t 300 --baseline skip
}

## Run 'cargo mutants' when it is available.
## When 'cargo-mutants' is not installed a warning is printed.
rule cargo_mutants: --conclusive 'is_cargo_tool_installed? mutants' cargo_test_units cargo_test_integrations -
rule cargo_mutants: --conclusive '!is_cargo_tool_installed mutants' -- warn "cargo mutants is not installed"

function cargo_outdated
{
    cargo outdated --color "${COLOR:-auto}" --quiet --exit-code 1
}

## Run 'cargo outedated' when it is available.
## When 'cargo-outdated' is not installed a warning is printed.
rule cargo_outdated: --conclusive 'is_cargo_tool_installed? outdated' -
rule cargo_outdated: --conclusive '!is_cargo_tool_installed outdated' -- warn "cargo outdated is not installed"

function cargo_audit
{
    cargo audit --color "${COLOR:-auto}" -D warnings --stale --quiet
}

## Run 'cargo audit' when it is available.
## When 'cargo-audit' is not installed a warning is printed.
rule cargo_audit: --conclusive 'is_cargo_tool_installed? audit' -
rule cargo_audit: --conclusive '!is_cargo_tool_installed audit' -- warn "cargo audit is not installed"

function cargo_semver_checks
{
    run_test --timeout 300 cargo semver-checks
}

## Run cargo semver-checks to test if a semver for a release is sufficient
rule cargo_semver_checks: --conclusive 'is_cargo_tool_installed? semver-checks' -
rule cargo_semver_checks: --conclusive '!is_cargo_tool_installed semver-checks' -- warn "cargo semver-checks is not installed"

function cargo_bench ## Run 'cargo bench'
{
    cargo --color "${COLOR:-auto}" bench
}

function cargo_publish ## Run 'cargo publish'
{
    cargo --color "${COLOR:-auto}" publish
}

