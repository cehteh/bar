#!/bash

require --opt tty_lib

# library of general functions

# TODO: add [-s|--state "extrastate"]

function memo ## [-c|-d] [cmd args..].. - memoize the result/stdout/stderr of commands, will always return the same result again
{
    if [[ $1 == "-c" ]]; then
        unset MEMO_RC MEMO_STDOUT MEMO_STDERR
        shift
    fi

    local delete=false
    if [[ $1 == "-d" ]]; then
        delete=true
        shift
    fi

    declare -gAi MEMO_RC
    declare -gA MEMO_STDOUT MEMO_STDERR

    # shellcheck disable=SC2155
    local key="$(hash_args "$$ $PWD $*")"

    if [[ $delete = true && -v MEMO_RC["$key"] ]]; then
        unset "MEMO_RC[$key]" "MEMO_STDOUT[$key]" "MEMO_STDERR[$key]"
    fi

    if [[ -v MEMO_RC["$key"] ]]; then
        echo -n "${MEMO_STDOUT[$key]}"
        echo -n "${MEMO_STDERR[$key]}" 1>&2
        return ${MEMO_RC["$key"]}
    elif [[ $# -ge 1 ]]; then
        touch "/tmp/$key.stdout" "/tmp/$key.stderr"
        local rc=0
        eval "$*" > >(tee "/tmp/$key.stdout") 2> >(tee "/tmp/$key.stderr" 1>&2) || rc=$?
        MEMO_RC["$key"]=$rc
        # we can not store null bytes in variables, use memodb when that is required
        MEMO_STDOUT["$key"]=$(<"/tmp/$key.stdout")
        MEMO_STDERR["$key"]=$(<"/tmp/$key.stderr")
        rm "/tmp/$key.stdout" "/tmp/$key.stderr"
        return "$rc"
    fi
}

function memofn ## <functionnames..> - rewrites a function into a function that uses 'memo'
{
    for fn in "$@"; do
        # rename the original function as nomemo_*
        eval "nomemo_$(declare -f "$fn")"
        # create a new function that calls memo with the original function
        eval "function $fn () { memo nomemo_$fn \"\$@\" ; }"
    done
}

function called_as
{
    local pat
    for pat in "$@"; do
        # shellcheck disable=2053
        [[ "$BAR_CALLED_AS" = $pat ]] && return 0
    done
    return 1
}

# elusive progress notice
function progress ## [message..] -
{
    if (( BAR_CHECK_LEVEL > 0 )); then
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 2 )) && tty_echo -n "${TTYERR[K_B]:-}  RUN: $*${TTYERR[cr]:-}" >&2
    else
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 1 )) && tty_echo -n "${TTYERR[K_B]:-}  RUN: $*${TTYERR[cr]:-}" >&2
    fi
}

function success ## [message..] -
{
    if (( BAR_CHECK_LEVEL > 0 )); then
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 2 )) && echo -e "${TTYERR[ce]:-}${TTYERR[g_B]:-}CHECK:${TTYERR[n]:-} $*" >&2
    else
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 1 )) && echo -e "${TTYERR[ce]:-}${TTYERR[g_B]:-}   OK:${TTYERR[n]:-} $*" >&2
    fi
}

function failure ## [message..] -
{
    if (( BAR_CHECK_LEVEL > 0 )); then
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 2 )) && echo -e "${TTYERR[ce]:-}${TTYERR[K_B]:-}CHECK: ${TTYERR[__S]:-}$*${TTYERR[n]:-}" >&2
    else
        (( "${BAR_VERBOSITY_LEVEL:-5}" > 1 )) && echo -e "${TTYERR[ce]:-}${TTYERR[r_B]:-} FAIL:${TTYERR[n]:-} $*" >&2
    fi
}

function uncond_call ## <rc> [message..] -
{
    declare -i rc="$1"
    shift
    if (( "${BAR_VERBOSITY_LEVEL:-5}" > 2 )); then
        if (( rc == 0 )); then
            echo -e "${TTYERR[ce]:-}${TTYERR[g_B]:-} EVAL:${TTYERR[n]:-} $*" >&2
        else
            echo -e "${TTYERR[ce]:-}${TTYERR[K_B]:-} EVAL:${TTYERR[n]:-} $*" >&2
        fi
    fi
}

function rule_autoload ## <name>
{
    trace "$*"
    local modname="${1#always_}"
    modname="${modname#is_}"
    modname="${modname#has_}"
    modname="${modname#try_}"
    modname="${modname%%_*}"
    require --opt "$modname"

    # when $name exists as command or function then create a rule for that
    if ! rule_exists "$1" && command -v "$1" >/dev/null ; then
        rule "$1:"
    fi
    rule_exists "$1" || die "no rule, command or function '$1' defined"
}

# checks whenever a shell command is in PATH
function is_command_installed
{
    if command -v "$1" >/dev/null; then
        return 0
    else
        info "$1 not installed"
        return 1
    fi
}
memofn is_command_installed

function bar_now() ## - returns the current timestamp in microseconds since epoch
{
    echo "${EPOCHREALTIME//[^0-9]/}"
}

function hash_args # - returns the sha1hash of all supplied args
{
    # shellcheck disable=SC2155
    local hash="$(sha1sum <<<"$*")"
    echo "${hash:0:40}"
}
