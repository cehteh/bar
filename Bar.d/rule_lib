#!/bash
#shellcheck disable=SC2016

# library for the rule functions
declare -g   BAR_CHECK_LEVEL=0         ## less alerting for check dependencies
declare -gAx BAR_RULES                 ## discovered rules as name:"clauseidx.."
declare -gAx BAR_RULES_RESULT          ## result "name args..":rc
declare -gA  BAR_RULE_FLAGS=(          ## [r]everse [u]nsealed [a]lways
    [CLEANUP]="r"
)
declare -gax BAR_CLAUSES=()            ## clause bodies enumerated
declare -gax BAR_CLAUSE_DEPS=()        ## dependencies for each clause
declare -ga  BAR_CLAUSE_FLAGS=()       ## [c]onclusive

function rule () ## [[--rule-flag].. <name>:] [--clause-flag].. [[!]dep[?] [arg]..].. [-- body..] - defines a rule
{
    trace "$*"

    local ruleflags=""
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
        --always)
            ruleflags+="a"
            ;;
        --reverse)
            ruleflags+="r"
            ;;
        *)
            break;;
        esac
        shift
    done

    local name="$1"
    if [[ "$name" = *: ]]; then
        name="${name%:}"
        shift
    else
        name=""
    fi

    local clauseflags=""
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
        --conclusive)
            clauseflags+="c"
            ;;
        *)
            break;;
        esac
        shift
    done

    local deps=()
    local has_body=
    local deps_for_cmd=
    while [[ $# -ne 0 ]]; do
        if [[ "$1" = - ]]; then
            shift
            deps_for_cmd=true
            break
        fi
        if [[ "$1" = -- ]]; then
            shift
            has_body=true
            break
        fi
        deps+=("$1")
        shift
    done

    # name given but no deps, no body, make body default to the rule name
    local body=""
    if [[ "${#deps[*]}" = 0 && "$#" == 0 && -n "$name" ]]; then
        body="$name "'"${RULE_ARGS[@]}"'
    elif [[ -n "$deps_for_cmd" && "$#" == 0 && -n "$name" ]]; then
        rule_exists "$name" && die "rule '$name' already defined"
        body="$name "'"${RULE_ARGS[@]}"'
    elif [[ -z "$name" ]]; then
        # default to MAIN when no rule name is given
        name="MAIN"
    elif [[ -z "$deps_for_cmd" && -z "${BAR_RULES[$name]:-}" ]]  && command -v -- "$name" >/dev/null ; then
        note "defining rule '$name' for existing command"
    fi

    if [[ -v BAR_RULES_RESULT[$name] ]]; then
        die "Can not add clause '$name: ${deps[*]}' after rule got evaluated"
    fi

    local ifs="$IFS"
    IFS=$'\n'
    BAR_CLAUSE_DEPS+=("${deps[*]}")
    IFS="$ifs"

    if [[ "$has_body" = true && $# = 0 ]]; then
        BAR_CLAUSES+=("$(cat)")
    else
        BAR_CLAUSES+=("$body$*")
    fi

    BAR_CLAUSE_FLAGS+=("$clauseflags")
    BAR_RULE_FLAGS["$name"]="${BAR_RULE_FLAGS[$name]:-}$ruleflags"
    BAR_RULES["$name"]+=" $(( ${#BAR_CLAUSES[@]} - 1))"
}

function newrule ## <name:> ... - creates a new rule with the given name, deletes the existing one
{
    rule_delete "${1%:}"
    rule "$@"
}

function rule_delete
{
    trace "$*"
    local name="$1"
    if [[ -z "$name" ]]; then
        die "rule_delete requires a rule name"
    fi

    if ! rule_exists "$name"; then
        error "rule '$name' does not exist"
        return 1
    fi

    if [[ -v BAR_RULES_RESULT[$name] ]]; then
        error "Can not delete rule '$name' after rule got evaluated"
        return 1
    fi

    unset "BAR_RULES[$name]"
    unset "BAR_RULES_RESULT[$name]"
}

function rule_rename ## <oldname> <newname> - renames a rule
{
    trace "$*"
    local oldname="$1"
    local newname="$2"

    if [[ -z "$oldname" || -z "$newname" ]]; then
        die "rule_rename requires two rule names"
    fi

    if ! rule_exists "$oldname"; then
        error "rule '$oldname' does not exist"
        return 1
    fi

    if [[ -v BAR_RULES_RESULT[$name] ]]; then
        error "Can not delete rule '$name' after rule got evaluated"
        return 1
    fi

    BAR_RULES["$newname"]="${BAR_RULES[$oldname]}"
    unset "BAR_RULES[$oldname]"
}

function rule_eval ## <name> [args..]
{
    trace "$*"
    # shellcheck disable=2155
    local rule_id="$(hash_args "$PWD $*")"
    local RULE_NAME="$1"
    shift

    # shellcheck disable=2034
    local RULE_ARGS=("$@")
    rule_exists "$RULE_NAME" || rule_autoload "$RULE_NAME"

    [[ -v BAR_RULES_RESULT["$rule_id"] ]] && {
        local rc="${BAR_RULES_RESULT[$rule_id]}"
        if [[ "$rc" == pending ]]; then
            die "recursive rule $RULE_NAME"
        else
            return "$rc"
        fi
    }

    local evaluate_always="${BAR_RULE_FLAGS[$RULE_NAME]:-}"
    BAR_RULES_RESULT["$rule_id"]="pending"

    local clauses="${BAR_RULES[$RULE_NAME]}"

    if [[ "${BAR_RULE_FLAGS[$RULE_NAME]}" = *r* ]]; then
        local rclauses=""
        for n in $clauses; do
            rclauses="$n $rclauses"
        done
        clauses=${rclauses# }
    fi

    local clause
    for clause in $clauses; do
        local skip=
        local dep
        local deps=()
        [[ "${#BAR_CLAUSE_DEPS[$clause]}" -gt 0 ]] && readarray -d $'\n' -t deps <<<"${BAR_CLAUSE_DEPS[$clause]}"

        local dep
        for dep in "${deps[@]}"; do
            local depname="${dep%% *}"
            declare -a depargs
            read -r -a depargs <<<"${dep:${#depname}+1}"
            local check=

            if [[ "$depname" = *"?" ]]; then
                check=true
                depname="${depname%?}"
            fi
            if [[ "$depname" = "!"* ]]; then
                check=negated
                depname="${depname:1}"
            fi
            if [[ "$depname" = *"~" ]]; then
                [[ -z "$check" ]] || die "~ can not be combined with ! or ?"
                check=unconditional
                depname="${depname%?}"
            fi
            [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL+1))

            # shellcheck disable=2155
            local dep_id="$(hash_args "$PWD $depname ${depargs[*]}")"
            local dep_rc="${BAR_RULES_RESULT[$dep_id]:-}"
            if [[ "${BAR_RULE_FLAGS[$depname]-a}" = *a* || -z "$dep_rc" ]]; then
                dep_rc=0
                # shellcheck disable=2086
                rule_eval "$depname" "${depargs[@]}" || dep_rc=$?
            fi

            if [[ "$check" = unconditional ]]; then
                uncond_call "$dep_rc" "$RULE_NAME: $depname~ ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                continue
            elif [[ "$dep_rc" == 0 && "$check" = negated ]]; then
                skip=true
                failure "$RULE_NAME: !$depname ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                break
            elif [[ "$dep_rc" != 0 ]]; then
                if [[ "$check" = true ]]; then
                    failure "$RULE_NAME: $depname? ${depargs[*]}"
                    skip=true
                    [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                    break
                elif [[ "$check" = negated ]]; then
                    success "$RULE_NAME: !$depname ${depargs[*]}"
                    [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                    continue
                fi
                # conclusive fail because of dep failure
                failure "$RULE_NAME: $depname ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                if [[ -n "$evaluate_always" ]]; then
                    unset "BAR_RULES_RESULT[$rule_id]"
                else
                    BAR_RULES_RESULT["$rule_id"]="$dep_rc"
                fi
                return "$dep_rc"
            else
                if [[ "$check" = true ]]; then
                    success "$RULE_NAME: $depname? ${depargs[*]}"
                elif [[ "$check" = negated ]]; then
                    success "$RULE_NAME: !$depname ${depargs[*]}"
                else
                    success "$RULE_NAME: $depname ${depargs[*]}"
                fi
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
            fi
        done

        if [[ "$skip" != true ]]; then
            local rc=0
            eval "${BAR_CLAUSES[$clause]}" || rc=$?
            if [[ "$rc" != 0 || "${BAR_CLAUSE_FLAGS[$clause]}" = *c* ]]; then
                if [[ -n "$evaluate_always" ]]; then
                    unset "BAR_RULES_RESULT[$rule_id]"
                else
                    BAR_RULES_RESULT["$rule_id"]="$rc"
                fi
                return "$rc"
            fi
        fi
    done

    if [[ -n "$evaluate_always" ]]; then
        unset "BAR_RULES_RESULT[$rule_id]"
    else
        BAR_RULES_RESULT["$rule_id"]=0
    fi
    return 0
}

function rule_exists ## <name> - checks if a rule is defined
{
    [[ -v BAR_RULES[$1] ]]
}

function rule_list ## [pattern] - lists all loaded rules or rules matching pattern
{
    local rule
    for rule in $(tr ' ' '\n' <<<"${!BAR_RULES[@]}" | sort); do
        # shellcheck disable=2053
        if [[ "$rule" = ${1:-*} ]]; then
            local clause
            for clause in ${BAR_RULES[$rule]}; do
                local dep
                local deps
                deps=""
                while read -r dep; do
                    [[ -n "$deps" ]] && deps+=" "
                    if [[ "$dep" = *" "* ]]; then
                        deps+="'$dep'"
                    else
                        deps+="$dep"
                    fi
                done <<<"${BAR_CLAUSE_DEPS[$clause]}"
                echo -n "$rule: $deps"
                if [[ -n "${BAR_CLAUSES[$clause]}" ]]; then
                    [[ -n "$deps" ]] && echo -n " "
                    echo -e "-- '${BAR_CLAUSES[$clause]}'"
                else
                    echo
                fi
            done
        fi
        echo
    done | less -SR
}
