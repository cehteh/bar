#!/bin/bash

### Provides help, extracts documentation from modules
###
### Inline documentation uses two or three hash characters. Three '###' is used for file level
### documentation to describe a file entirely. Two '##' are used in different contexts:
###
### Variable definitions that use the 'declare' keyword can use '##' at the end of the same
### line to document the variable.
###
### Functions can be documented in the form 'function name ## arguments - description'.
### Any lines following that start with optional white spaces followed by '##' and then
### documentation text will append to the functions documentation.
###
### Rules are documented by lines starting with '##' followed by documentation text,
### eventually followed by a rule/clause definition.
###
### Only variables, functions and rules that have doc comments are included in the output.

function help
{
    if is_command_installed less; then
        less -R
    elif is_command_installed more; then
        more
    else
        cat
    fi <<EOF

  bar -- BAshRulez the bash rule evaluator

ABOUT

  Bar is a command runner that decides the order and which commands to run by rules. It to
  define rules that dependently and conditionally evaluate shell statements.  This is similar
  to other tools such as 'make' or 'just' but adds some opinionated differences. There is
  support for using bar as driver for githooks for automating workflows.

  The notable differences to other similar tools are:

  * Rules in bar can have multiple clauses.
  * Normally rules are conjunctive, when a clause of a rule fails then the rule fails and not
    further evaluated.
  * Rules can made disjunctive, then a rule succeeds on the first succeeding clause.
  * Clauses can be conditionally skipped.
  * The results of rules are cached. Normally rules are evaluated only once, although there is
    a form to define rules that always evaluate.
  * We have a module that can memorize commands persistently and schedule evaluation to the
    background. A later instance can pick up the results from this background evaluation.

  When you read this because you seen 'bar' or '.bar' used in a repository then you may look
  at INITIAL INSTALLATION below.


QUICKSTART

  When you cloned a project that uses bar then you can:

   ./bar                # just runs whatever the maintainer decided as default
   ./bar watch          # watches the project for changes and runs the default
   ./bar watch fastchk  # watches the project for changes and run fast checks
   ./bar activate       # installs githooks and other local prep work

  When you want to install and use it in your own projects

   git clone https://seed.pipapo.org/z3WhBdHt1VVNyeQ61zpY66pNzuSrP.git bar
   cd bar
   ./bar init_install ~/.local/
   git pull   # to get updates

  Then you can initialize it in your projects with

   bar init
   git add Barf Bar.d .gitignore
   git commit -m 'start using bar'

   bar init_update  # for updating the version stored in the project

  The second personality of bar is 'please' eg.:

   please wake <hostname>     # sends a wake-on-lan packet to a host
   please suspend <hostname>  # remotely sends a host to suspend-to-ram


INVOCATION AND SEMANTICS

    bar [rulefile] [rule [arguments..]]
    please [rulefile] [rule [arguments..]]
    ./bar [rulefile] [rule [arguments..]]
    <symlink> [arguments..]

  Starts by loading all initial modules (those which have underscores in their name) and the a
  rulefile, which is either "Barf", "barf", ".Barf", ".barf" when called as 'bar' or "Pleasef"
  "pleasef" ".Pleasef" ".pleasef" "\$HOME/.Pleasef" when called as 'please' and when the first
  argument is not a file.

  The duality of having 'bar' installed as 'please' is not only for making it more
  polite. This allows for a user to have private '.Pleasef' defining rules that are for common
  administration tasks distinct from versioned per-project 'Barf' and 'Bar.d' rules.

  Note that the rules for looking up the Barf/Pleasef and the modules are somewhat distinct.
  Nevertheless modules are in either way only loaded from a single directory and are not
  located in different paths. This is a opinionated choice to make the module system
  self-contained and not depend on secondary locations.

  Then the given rule (or MAIN) with the supplied arguments becomes evaluated. Finally if
  exists a 'CLEANUP' rule is evaluated.

  The exit code of the invocation is the exit code of the main rule.

  Just calling 'bar' without any arguments will evaluate the 'MAIN' rule which should be what
  people expect by default. Other useful rules like 'help' for this documentation are defined
  by modules.

  When called by a symlink then the standard rulefile (as above) is loaded and instead 'MAIN'
  a rule with the same name as the symlink is called with all arguments passed.


INITIAL INSTALLATION

  Bar can be invoked in different ways:

  1. Installed in \$PATH:
     To make this work it is best to clone bar locally and symlink the checked out files
     to your '.local/' tree. This allows easy upgrades via git:

     When you have radicle (https://radicle.xyz/) installed you can clone it with:

       rad clone rad:z3WhBdHt1VVNyeQ61zpY66pNzuSrP

     Otherwise it can be cloned by git with:

       git clone https://seed.pipapo.org/z3WhBdHt1VVNyeQ61zpY66pNzuSrP.git bar

     Then you can install it in your ~/.local tree with:

       cd bar
       ./bar init_install ~/.local/

     This creates symlinks to 'bar', 'please', 'Bar.d', 'Barf.default', 'Please.default' in ~/.local
     and symlinks 'Bar.d/*' to '~/.config/please/'.

     Now 'bar' is installed, check it with 'bar help'

  2. The local './.bar' initialized from above:
     Since bar is a bash script its easy to version and ship it with other software.
     To initialize it in a current directory use either of:

       bar init          # creates bar, Barf, Bar.d/
       bar init --hidden # creates .bar, .Barf, .Bar.d/

     After that Barf can be customized, unnecessary modules in Bar.d/ may be deleted.
     Once that is done these files should be put under version control.

     When the installed bar from 1. becomes updated then a local version can be updated by:

       bar init --update

     This only updates 'bar' and any existing modules in 'Bar.d/' but will not touch the
     'Barf' file since that is meant for local customszation.

       bar init_update_merge_barf

     Will do a merge of the installed 'Barf' file with the local one. This *will* leave 3-way
     conflict markers behind when there are changes. These must be manually resolved!

     The updated files should then be committed to version control.

  3. githooks symlinked from './.git/hooks/*' -> '../../bar'
     'bar' has support to be used as githooks. This needs manual enabling. Individual hooks can be
     enabled or disabled with 'bar githook_enable <hook>' and 'bar githook_disable <hook>'.
     For exiting projects using 'bar' a maintainer can setup rules to activate all necessary hooks.
     This then can be activated by './bar activate'.


GIT HOOK ACTIVATION

  Bar will be inert in a project that ships with bar initialized. One can call it manually by
  './bar'.  A maintainer of the project may define 'activate' rules that activate
  githooks. These are then activated by './bar activate'. This will create symlinks in the
  '.git/hooks/' directory to the 'bar' script. These hooks will then be executed when the
  respective git hook is triggered. The rules for these hooks are defined in the 'Barf' file
  in the project directory.


RULE SEMANTICS

  Rules are a named, ordered collection of clauses. They are considered pure with inputs being
  the current directory name and the rules arguments. Note that the content of files is *not*
  considered and the outcome of the rule should not depend on external variables. By being
  pure rules are evaluated lazily, only once, the result of a rule is cached. This means that
  rules, esp. the actions within the body must have deterministic sematics. For performance
  reasons this is not enforced but one may observe surprising behavior when this requirement
  is violated.

  Rules will be autoloaded on demand from modules in 'Bar.d/' (see below AUTOMATIC MODULE
  LOADING). For rules where this fails a fallback exits that creates an implicit rule for any
  command and shell function defined with a body calling the respective command.

  Each clause in a rule has its own set of dependencies. Dependencies are other rules which
  are evaluated in order. When a (normal) dependency fails then rule it is considered to be
  failed as well and no further attempts to evaluate following dependencies and clauses are
  made.

  Dependencies can be used as 'checking' dependency which either expects the dependency to
  succeed (suffixed with a '?') or fail (prefixed with a '!'). When such a checking dependency
  fails then the rest of the current clause is skipped. This allows conditional evaluation.
  Further dependencies may be tagged as unconditional by suffix them when a tilde '~', these
  are just evaluated but rules evaluation will proceed unconditionally even if such a
  dependency fails.

  Finally every clause can have an optional body. This are shell commands executed when all
  dependencies succeeded. Because of quotiung in shell becomes a but unwieldly there are
  shortcuts to make the body refer to shell functions, this should be preferred.


RULE DEFINITION SYNTAX

  rule [[--rule-flag].. <name>:] [--clause-flag].. [[!]deps[?|~][??] args..]..
  rule [[--rule-flag].. <name>:] [--clause-flag].. [[!]deps[?|~][??] args..].. -
  rule [[--rule-flag].. <name>:] [--clause-flag].. [[!]deps[?|~][??] args..].. -- [body..]

  Adds a clause to 'name' or 'MAIN'.

  * [--rule-flag]

    Sets flags for a rule. Flags are additive and affect the rule, not single clauses.

    --always
      The result is not cached and the rule will be always evaluated again.

    --reverse
      The clauses of this rule will be evaluated in reverse order

    --disjunct
      Makes the clauses of this rule disjunctive. The rule will succeed with the first
      successful clause. Normally clauses are conjunctive and fail with the first failing
      clause.

    --meta
      Metarules do not have their own clause local variable. This allow them to modify
      the clause locals of the calling rule. 'clause_local' for example is a metarule.
      User defined rules that want to modify clause locals will need to be meta too.
      See 'try_cargo_toolchain' for an example.

  * [<name>:]

    A rule can have a optional name (suffixed with a colon).  When the name is not given it
    defaults to 'MAIN'.  Rules that have only a name but no dependencies and no body create a
    body that calls a bash command or function with the same name as the rule passing rule
    arguments to it.

  * [--clause-flag]..

    Sets flags affecting this clause only.

    --conclusive
      Makes a clause result conclusive, if not skipped no more clauses will be tried.

  * [[!]deps[?|~][??] args..]..

    Dependencies, are a list of other rules that this rule depends on. These will be executed
    in order. If any of the dependencies fails then this rule is considered failed as well, no
    further dependencies, bodies or clauses are executed unless this dependency is a checking
    or unconditional one.

    A dependency can be either prefixed with an exclamation mark or suffixed with question
    marks or a tilde. The exclamation mark prefix expects the dependency to fail and will
    continue then, if the dependency succeeds then the remaining dependencies and the rule
    body are skipped. With a question mark as suffix the dependency is expected to succeed,
    when it fails then the rest of the dependencies and the rule body is skipped. With a tilde
    as suffix outcome of the dependencny is ignored and the rest of the dependencies and the
    rule body is executed.  The difference here is that these checking dependencies decide if
    a clause should be skipped or succeed while a failure on a normal dependency will fail a
    rule instantly. When a rule is suffixed with two question marks then this behaves like
    "'rule_exists? dep' dep". Making this dependency optional. This can be combined with the
    another question mark, a tilde, or explamation mark prefix. This is commonly used to
    define optional rule hooks.

    Dependencies can have arguments. When provided then the dependency and its arguments must
    be quoted. These arguments are passed in the 'RULE_ARGS' array to the body of the rule.

  * -

    When there is a single hypen '-' at the end of a rule definition then the rule body is a
    call to a command or function of the same name as the rule with all arguments passed. This
    is used when one wants to add dependencies to a existing command or function.

  * -- [body..]

    After a double hyphen a optional rule body follows. This are the commands to
    execute for this clause. If these fail then the rule is considered failed. When a name but
    no body and no dependencies are given then the body defaults to the rule name. This makes
    it easy to translate simple parameterless commands and functions to rules. Usually the
    body has to be quoted to prevent shell expansions at definition time. Later when a rule
    becomes evaluated the body is passed to 'eval'.

    When the body is omitted, then the rule body is read from stdin. This allows to use
    heredocs or herestrings or read the body from a file.

    When a rule overrides an existing command a 'NOTE' will be printed on higher verbosity
    levels. The user is responsible for sensible overiding of commands.

  Rules must not have mutually recursive dependencies. When such is detected the
  evaluation aborts.

  Examples:

   # Add a clause to 'MAIN'
   rule -- echo hello

   # Different ways to define rule bodies
   rule foo_ok: -- echo inline
   rule foo_ok: -- '
       echo inline quoted
   '
   rule foo_ok: -- <<<"echo herestring"
   rule foo_ok: -- <<EOR
      echo heredoc
   EOR

   # Make a rule that fails
   rule foo_fail: -- false

   # functions and commands can be used as rules, this should be preferred
   function example
   {
       echo "i am example called with \$*"
   }

   # add a tests rule with 3 clauses
   rule tests: foo_ok? 'example "argument"' -- echo "foo_ok success"
   rule tests: !foo_ok -- echo "This is never called, but MAIN still passes"
   rule tests: foo_fail? -- echo "This is also never called"

   # add tests to MAIN
   rule tests

  For some more examples see the 'example' file that ships with bar.


  Special Rules and Names

    Rules that do not have a name fall back to 'MAIN', when no rule name is given at execution
    time then 'MAIN' will be evaluated.

    If exist 'SETUP', 'PREPROCESS', 'POSTPROCESS' and 'CLEANUP' will be called.
     * SETUP
       Should set up the environment for all subsequent evaluation. Setup rules
       should be self-sufficient and not expect a working environment yet.
       A failure here will abort bar.
     * PREPROCESS
       Doing any preparatory tasks within the set up environmnet.
       A failure here will abort bar.
     * MAIN
       When the bar is not called via a symlink or the user did not provide a rule to
       evaluate, then MAIN is the default rule. Otherwise the user supplied or symlink-deduced
       rulename will be evaluated. The result of this rule determines the exitcode of bar.
     * POSTPROCESS
       Is for evaluating things after the main rule finsihed. The environment and
       state is still the same as in the main rule. A failure here will be reported but not
       reflected in the exitode.
     * CLEANUP
       Is for removing temporary resources and doing any other kind of cleanup work. This
       means the state and environment at cleanup time may be differen/partially destructed and
       should not be relied upon. Clauses in the CLEANUP rule are evaluated in reverse order of
       their definition. A failure here will be reported but not reflected in the exitcode.

    After a rule that is not flagged with '--always' got evaluated it is not allowed to add
    more clauses to it anymore, as the outcome would be unexpected and impure.


RULE ENVIRONMENT

  Rules implicitly depend on the arguments passed and the current directory they run in. Any
  other state or environment variable is not considered. When the result of a rule would
  depend on such external state then the rule is impure and may lead to wrong
  results.


MODULES

  Modules are shell snippets located in 'Bar.d/', 'bar.d/', '.Bar.d/' or '.bar.d/' when called
  as 'bar' or symlink or '~/.config/please' when called as 'please'.  All modules that contain
  a underscore in their name are loaded at startup. Modules with alphabetic names without
  underscores are lazy loaded on demand.

  The first variant for modules that are initially loaded is used for modules that define
  helper functions that don't have associated rules or rules that are primarly used for
  checking conditions before delegating to the actual rules which do the work.

  The second variant is for mudules that define rules which are self-contained and can't
  extend existing rules with new clauses. Here are the rules and functions which do the actual
  work.

  The reason for this is that some will add clauses to existing rule which must be done before
  the rules are evaluated while we can improve performance by lazy loading modules that are
  not always needed.

  The module loader derives the module name from the rule name by removing any prefixes and
  suffixes. Thus the rules which shall trigger loading must follow the naming schema with the
  module name after the prefixes in the rule name.

  Per convention 'name_rules' is a module that contains the rules (and few functions) that
  that add clauses to other rules to make 'name' accessible. 'name_lib' contains support
  functions other modules may use (with 'require name_lib') and 'name' are the autoloaded
  functions and rules that implement the actual functionality of 'name'.


AUTOMATIC MODULE LOADING

  Rule names may include underscores, then the word before the first underscore is used to
  determine a module name used for auto-loading rules. They can have special prefixes which
  are removed when auto-loading:

  - 'is_', 'has_' and 'try_' are reserved for check rules they don't have any special
    semantic except for being stripped at auto loading.

  When a rule is not found then a module name is derived from the rule name by removing the
  'try_', 'is_', 'has_' prefixes and cutting off anything behind the first
  underscore. Eg. 'try_module_check' results in 'module'. This is then searched as
  'Bar.d/module', 'bar.d/module', '.Bar.d/module' or '.bar.d/module' (or respective please
  variants) and loaded if present. Thus modules that are automatically loaded must be named by
  single word without underscores.


STANDARD RULES

  Bar ships with a module that defines a set of standard rules where other modules can add
  clauses to. Check 'Bar.d/std_rules' for details.

  'SETUP', 'PREPROCESS', 'MAIN', 'POSTPROCESS' and 'CLEANUP' are special rule names called
  approbiately.

  The 'clause_local [var[=value]]' is for defining variables that are local to a clause.  Only
  scalars can be clause local. Ideally this should be used as dependency and setting a a
  variable to a value. It can be used in a function as well esp when creating other metarules.


MAIN API

$(help_describe_files "$BAR_SELF")


MODULE API/RULES

$(help_describe_files "$BAR_DIR"/* )


LICENSE

    bar -- BAsh Rulez
    Copyright (C) 2025  Christian Thäter <ct.bar@pipapo.org>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
EOF
}


function help_describe_files
{
    local file
    for file in "$@"; do
        if help_describe_file "$file"; then
            help_describe_variables "$file"
            help_describe_functions "$file"
            help_describe_rules "$file"
        else
            warn "$file has no top level doc"
        fi
    done
}


function help_describe_file
{
    awk '
    function printout(text) {
             out = out text "\n"
    }

    /^###/{
        if (match($0, /^###( )?(.*)/, m)) {
           printout( indent m[2])
           indent="    "
        }
        next
    }

    END{
        name = FILENAME
        gsub(/^.*\//, "", name)
        if (out != "") {
           print "  " name " - " out
        } else {
           exit 1
        }
    }
    ' "$1"
}

function help_describe_functions
{
    awk '
    function printout(text) {
             out = out text "\n"
    }

    /^function[ \t]+[A-Za-z_][A-Za-z0-9_]*[ \t]*##/ {
      if (match($0, /^function[ \t]+([A-Za-z_][A-Za-z0-9_]*)[ \t]*## (((.*) )?- )?(.*)$/, m)) {
        printout()
        printout("      " m[1] " " m[4])
        printout("        " m[5])
        next
      }
    }

    /^[ \t]+##.*/ {
      sub(/^.*##[ ]?/, "")
      printout("        " $0)
      next
    }

    END{
        if (out != "") {
           print "    Functions:"
           print out
        }
    }
    ' "$1"
}

function help_describe_rules
{
    awk '

    function printout(text) {
             out = out text "\n"
    }

    /^rule([ \t]+[A-Za-z_-][A-Za-z0-9_-]*)+:/ {
      if (descr != "" ) {
         if (match($0, /^rule([ \t](--[a-z_-]*)?)+([A-Za-z_][A-Za-z0-9_]*:)/, m)) {
            printout("      " m[3])
            printout(descr)
            descr=""
         }
      }
      next
    }

    /^##/ {
      sub(/^##[ ]?/, "")
      descr = descr "        " $0 "\n"
      next
    }

    {
      descr = ""
      next
    }

    END{
        if (out != "") {
           print "    Rules:"
           print ""
           print out
        }
    }
    ' "$1"
}



function help_describe_variables
{
    awk '
    function printout(text) {
             out = out text "\n"
    }

    /declare[ \t]+.*##/ {
      if (match($0, /declare[ \t]+(-([a-zA-Z]+))? ([A-Za-z_][A-Za-z0-9_]*)="(.*)"[ \t]*## (.*)$/, m)) {
        printout("")
        printout("      " m[3] " (" m[2] ")")
        printout("        " m[5])
        printout("        Default: " m[4])
        next
      }
    }

    END{
        if (out != "") {
           #print ""
           print "    Variables:"
           print out
        }
    }
    ' "$1"
}
