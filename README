
  bar -- BAshRulez the bash rule evaluator

ABOUT

  Bar allows one to define rules that dependently and conditionally evaluate shell statements.
  This is similar to other tools such as 'make' or 'just' but adds some opinionated
  differences. There is support for using bar as driver for githooks for automating workflows.

  Rules in bar can have multiple clauses. When any clause of a rule fails then the rule is
  considerd failed as well and not further evaluated. The results of rules are cached. Clauses
  can be conditionally skipped.

  When you read this because you seen 'bar' or '.bar' used in a repository then you may look
  at INITIAL INSTALLATION below.


INVOCATION

    bar [rulefile] [rule [arguments]]
    ./bar [rulefile] [rule [arguments]]

  Starts by loading all modules that have underscores in their name (not autoloaded ones) and
  the main rulefile, which is "Barf", "barf", ".Barf", ".barf" when the first argument is not
  a file.

  Then the given rule (or MAIN) with the supplied arguments becomes evaluated. Finally if
  exists a 'CLEANUP' rule is evaluated.

  The exit code of the invocation is the exit code of the main rule.

  Just calling 'bar' without any arguments will evaluate the 'MAIN' rule which should be what
  people expect by default. Other useful rules like 'help' for this documentation are defined
  by modules.


RULE SEMANTICS

  Rules are a named, ordered collection of clauses. They are considered pure with inputs being
  the current directory name and the rules arguments. Note that the content of files is *not*
  considered and the body should not depend on external variables. By being pure rules are
  evaluated lazily and only once, the result of a rule is cached. This means that rules, esp
  the actions within the body must have deterministic sematics. For performance reasons this
  is not enforced but one may observe surprising behavior when this requirement is violated.

  An exception are rule names that start with 'always_', such rules results are not taken from
  the cache and the rule is always evaluated.

  Rules will be autoloaded on demand from modules in 'Barf.d/' (see below AUTOMATIC MODULE
  LOADING). For rules where this fails a fallback exits that creates an implicit rule for any
  command and shell function defined with a body calling the respective command.

  Each clause in a rule has its own set of dependencies. Dependencies are otehr rules which
  are evaluated in order. When a (normal) dependency fails then rule evaluating it is
  considered to be failed as well and no further attempts to evaluate following dependencies
  and clauses are made.

  Dependencies can be marked as 'checking' dependency which either expects the dependency to
  succeed (suffixed with a '?') or fail (prefixed with a '!'). When such a checking dependency
  fails then the rest of the current clause is skipped. This allows conditional evaluation.
  Further some dependencies may be tagged as unconditional, these are just evaluated but the
  dependent rules evaluation proceeds even if such a unconditional rule fails.

  Finally every clause can have an optional body. This are shell commands executed when all
  dependencies succeeded.


RULE DEFINITION SYNTAX

  rule [<name>:] [[!]deps[?|~] args..]..
  rule [<name>:] [[!]deps[?|~] args..].. -
  rule [<name>:] [[!]deps[?|~] args..].. -- [body..]

  * [<name>:]

    A rule can have a optional name (suffixed with a colon).  When the name is not given it
    defaults to 'MAIN'.
    Rules that have only a name but no dependencies and no body create a body that
    body that calls a bash command or function with the same name as the rule passing
    rule arguments to it.

  * [[!]deps[?|~] args..]..

    Dependencies, are a list of other rules that this rule depends on. These will be executed
    in order. If any of the dependencies fails then this rule is considered failed as well, no
    further dependencies, bodies or clauses are executed unless this dependency is a checking
    or unconditional one.

    A dependency can be either prefixed with an exclamation mark or suffixed with a question
    mark or tilde. The exclamation mark prefix expects the dependency to fail and will
    continue then, if the dependency succeeds then the remaining dependencies and the rule
    body are skipped. With a question mark as suffix the dependency is expected to succeed,
    when it fails then the rest of the dependencies and the rule body is skipped. With a tilde
    as suffix outcome of the dependencny is ignored and the rest of the dependencies and the
    rule body is executed.  The difference here is that these checking dependencies decide if
    a clause should be skipped or succeed while a failure on a normal dependency will fail a
    rule instantly.

    Dependencies can have arguments. When provided then the dependency and its arguments must
    be quoted. These arguments are passed in the 'RULE_ARGS' array to the body of the rule.

  * -

    When there is a single hypen '-' at the end of a rule definition then the rule body is a
    call to a command or function of the same name as the rule with all arguments passed. This
    is used when one wants to add dependencies to a existing command or function.

  * -- [body..]

    After a double hyphen a optional rule body follows. This are the commands to execute for
    this clause. If these fail then the rule is considered failed. When a name but no body and
    no dependencies are given then the body defaults to the rule name. This makes it easy to
    translate simple parameterless commands and functions to rules. Usually the body has to be
    quoted to prevent shell expansions at definition time. Later when a rule becomes evaluated
    the body is passed to 'eval'.

    When there was as double hyphen but no remaining arguments, then the rule body is read
    from stdin. This allows to use heredocs or herestrings or read the body from a file.

  Rules must not have mutually recursive dependencies. When such is detected the
  evaluation aborts.

  Examples:

    # Add a clause to 'MAIN'
    rule -- echo hello

    # Different ways to define rule bodies
    rule foo_ok: -- echo inline
    rule foo_ok: -- '
        echo inline quoted
    '
    rule foo_ok: -- <<<"echo herestring"
    rule foo_ok: -- <<EOR
      echo heredoc
    EOR

    # Make a rule that fails
    rule foo_fail: -- false

    # functions and commands can be used as rules
    function example
    {
        echo "i am example called with "
    }

    # add a tests rule with 3 clauses
    rule tests: foo_ok? 'example "argument"' -- echo "foo_ok success"
    rule tests: !foo_ok -- echo "This is never called, but MAIN still passes"
    rule tests: foo_fail? -- echo "This is also never called"

    # add tests to MAIN
    rule tests

  Special Rule Names

    Rules that do not have a name fall back to 'MAIN', if no rule name is given at execution
    time then 'MAIN' will be called.  If exist 'CLEANUP' will be called after after the main
    rule was evaluated. Normally rules are sealed and one can not add clauses to existing
    rules after rule evaluation stated. As the outcome would be unexpected and impure.
    As an exception adding clauses to 'CLEANUP' is allowed.


MODULES

  Modules are shell snippets located in 'Barf.d/', 'barf.d/', '.Barf.d/' or '.barf.d/'.
  All modules that contain a underscore in their name are loaded at startup.
  Modules with alphabetic names without underscores are lazy loaded on demand.

  The first variant for modules that are unconditionally loaded is used for modules that
  define helper functions that don't have associated rules or rules that are primarly used for
  checking conditions before delegating to the actual rules which do the work.

  The second variant is for mudules that define rules which are self-contained and can't
  extend existing rules with new clauses. Here are the rules which do the actual work defined.

  The reason for this is that some will add clauses to existing rule which must be done before
  the rules are evaluated while we can improve performance by lazy loading modules that are
  not always needed.

  The module loader derives the module name from the rule name by removing any prefixes and
  suffixes. Thus the rules which shall trigger loading must follow the naming schema with the
  module name after the prefixes in the rule name.


AUTOMATIC MODULE LOADING

 Rule names may include underscores, then the word before the first
    underscore is used to determine a module name used for auto-loading rules. They can have
    special prefixes which are removed when auto-loading:

    - 'is_' and 'has_' are reserved for check rules they don't have any special semantic
      except for being stripped at auto loading.
    - The result of rules which start with 'always_' will no be cached and if used as
      dependency it will always be evaluated.  This is useful for stateful rules like
      counters. Can be combined in front of 'is_' or 'has_'. Is also stripped for auto
      loading.


  When a rule is not found then a module name is derived from the rule name by removing the
  'always_', 'is_', 'has_' prefixes and cutting off anything with and behind the first
  underscore. Eg. 'always_if_module_check' results in 'module'. This is then searched as
  'Barf.d/module', 'barf.d/module', '.Barf.d/module' or '.barf.d/module' and loaded if
  present. Thus modules that are automatically loaded must be named by single word without
  underscores. This automatically loaded modules can only add new rules but not add clauses to
  existing rules.

  Modules that contain underscores are unconditionally loaded at startup. These can add
  clauses to existing rules because no rule evaluation took place yet.


STANDARD RULES

  Bar ships with a module that defines a set of standard rules where other modules can add
  clauses to. Check 'Barf.d/std_rules' for details.

  Aside from 'MAIN' and 'CLEANUP' there are no other predefined rules.


INITIAL INSTALLATION

  Bar can be invoked in different ways:

  1. Installed in $PATH:
     To make this work it is best to clone bar locally and symlink the checked out files
     to your '.local/' tree. This allows easy upgrades via git:

     When you have radicle (https://radicle.xyz/) installed you can clone it with:

       rad clone rad:z3WhBdHt1VVNyeQ61zpY66pNzuSrP

     Otherwise it can be cloned by git with:

       git clone https://seed.pipapo.org/z3WhBdHt1VVNyeQ61zpY66pNzuSrP.git bar

     Then you can install it in your ~/.local tree with:

       cd bar
       ./bar init_install ~/.local/

     This creates symlinks to 'bar' 'Barf.d' and 'Barf.default' in ~/.local to the
     git checkout.

     Now 'bar' is installed, check it with 'bar help'

  2. The local './.bar' initialized from above:
     Since bar is a bash script its easy to version and ship it with other software.
     To initialize it in a current directory use either of:

       bar init          # creates bar, Barf, Barf.d/
       bar init --hidden # creates .bar, .Barf, .Barf.d/

     After that Barf can be customized, unnecessary modules in Barf.d/ may be deleted.
     Once that is done these files should be put under version control.

     When the installed bar from 1. becomes updated then a local version can be updated by:

       bar init --update

     This only updates 'bar' and any existing modules in 'Barf.d/' but will not touch the
     'Barf' file since that is meant for local customszation.

       bar init_update_merge_barf

     Will do a merge of the installed 'Barf' file with the local one. This *will* leave 3-way
     conflict markers behind when there are changes. These must be manually resolved!

     The updated 'bar' should then be committed to version control.

  3. githooks symlinked from './.git/hooks/*' -> '../../bar'
     'bar' has support to be used as githooks. This needs manual enabling. Individual hooks can be
     enabled or disabled with 'bar githook_enable <hook>' and 'bar githook_disable <hook>'.
     For exiting projects using 'bar' a maintainer can setup rules to activate all necessary hooks.
     This then can be activated by 'bar activate'.


LICENSE

    bar -- BAsh Rulez
    Copyright (C) 2025  Christian Thäter <ct.bar@pipapo.org>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
