#!/bash
## managing lockfiles
##

# Lockfiles: Manage ownership of resources.  We can create or wait on a lockfile with
# lock_wait and remove it with lock_remove.  These locks are recursive the same process can
# lock_wait on the same lockfile multiple times which must be paired with the same numbers of
# lock_remove to unlock it.
# lock_next does hand over hand locking locking a new lockfile and then releases the original one.
# lock_remove takes a name as parameter and removes the lockfile if it is owned by the current process.

declare -gA LOCK_REC=()

function lock_wait #api {lockfile} - lock a lockfile, waits until we have the lock
{
    # shellcheck disable=SC2155
    local lockfile="$(realpath -s "$1")"
    if (( LOCK_REC["$lockfile"] > 0 )); then
        (( LOCK_REC["$lockfile"]+=1 ))
        trace "recursive lock: $1 as $$"
        return 0
    fi

    # Create a temporary lockfile specific to this process
    local tmp_lockfile="${1}.$$"

    # Put our PID in the temporary file
    echo $$ > "$tmp_lockfile"

    # backoff with a binomial sequence
    declare -i backoff=1

    # Try to atomically acquire the lock
    while ! ln -s "$tmp_lockfile" "$1" 2>/dev/null; do
        # Lock exists, check if it's stale
        if [[ -L "$1" ]]; then
            # shellcheck disable=SC2155 # want to ignore errors here
            local lockfile_target=$(readlink "$1")
            local lockpid="${lockfile_target##*.}"

            # Check if the process still exists
            if kill -0 "$lockpid" 2>/dev/null; then
                # Wait for the process to exit
                trace "wait: $lockpid to complete"
                wait "$lockpid" 2>/dev/null || sleep "${backoff:: -1}.${backoff: -1}"
                (( backoff < 100 )) && (( backoff+=1 ))
            else
                rm -f "$1"
                continue
            fi
        fi
    done
    # remove stale tmp_lockfiles
    local file
    for file in "$1."*; do
        local lockpid="${file##*.}"
        [[ "$lockpid" != "$$" && "$(cat "$file")" = "$lockpid" ]] &&
            ! kill -0 "$lockpid" 2>/dev/null &&
            rm -f "$file"
    done

    LOCK_REC["$lockfile"]=1

    trace "locked: $1 as $$"
}

function lock_next # old new - hand over hand locking
{
    lock_wait "$2"
    lock_remove "$1"
}

function lock_remove #api {name} - remove a lockfile, unlock
{
    # shellcheck disable=SC2155
    local lockfile="$(realpath -s "$1")"

    (( LOCK_REC["$lockfile"]-=1 ))
    if (( LOCK_REC["$lockfile"] > 0 )); then
        trace "recursive unlock $1"
        return 0
    fi

    if [[ -L "$1" ]]; then
        unset "LOCK_REC[$lockfile]"

        # shellcheck disable=SC2155 # want to ignore errors here
        local lockfile_target=$(readlink "$1")
        local lockpid="${lockfile_target##*.}"

        if [[ "$lockpid" = "$$" ]]; then
            trace "unlock $1"
            # Remove both the lock and the temporary file
            rm -f "$1"
            rm -f "$lockfile_target"
            return 0
        else
            error "$1 is not ours (we are $$, owned by $lockpid)"
            return 1
        fi
    elif [[ -f "$1" ]]; then
        error "$1 is not a symbolic link lockfile"
        return 1
    else
        error "$1 does not exist"
        return 1
    fi
}

