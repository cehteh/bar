#!
#/bash

## state db and log

# A statedb is a persistent database which records the stdout, stderr and exitcode/state of commands

# in the form of 'state hash command..'.
# Where state is either a numeric exit code or 'bg' for backgrounding.
# We may have multiple state logs that are distinguished by their name and the tree hash.
# Each state log is used to cache the result of tests and to schedule background jobs.
# A state log is appended to after each test is run.
#
# the state dir .bar.s/<timestamp>-<treehash>/ contains:
#  - .bar_<tag>.lock - the lock per tag/operation the state dir
#  - .bar_<tag>.log  - log for the cached states holding "exitcode cmdhash cmd args.."
#  - <cmdhash>.stdout   - stdout of commands
#  - <cmdhash>.stderr   - stderr of commands
#
# At runtime the STATEDB stores a "cmd args" : "exitcode hash" relation.
# When a log exists then at startup then STATE_DB is replayed from the log.

# PLANNED: store stdouthash in STATEDB

# TODO: document that this needs clean .gitignore
# TODO: rule statedb_eval: statedb_init -
#

require lock

# (re-) initializes a state log, acquires a lock
function statedb_init #api <tag> - initializes a state log
{
    trace "$*"

    # main lock will be released hand-over-hand
    lock_wait "$BAR_TOPLEVEL/.bar"
    mkdir -p "$BAR_TOPLEVEL/.Bar.s"

    # PLANNED: make tree_hash a rule that can be overridden by the user
    # shellcheck disable=SC2155
    local tree_hash="$(git_tree_hash -c --other)"

    # shellcheck disable=SC2155
    declare -gx STATEDB_DIR="$(find "$BAR_TOPLEVEL/.Bar.s" -type d -name "*-$tree_hash" | tail -1)"
    if [[ -z "$STATEDB_DIR" ]]; then
        STATEDB_DIR="$BAR_TOPLEVEL/.Bar.s/$BAR_TIMESTAMP-$tree_hash"
        info "creating: $STATEDB_DIR"
        mkdir -p "$STATEDB_DIR"
    else
        info "using existing: $STATEDB_DIR"
    fi
    lock_next "$BAR_TOPLEVEL/.bar" "$STATEDB_DIR/.statedb"

    readonly STATEDB_DIR

    declare -gx STATEDB_LOG="$STATEDB_DIR/.log"
    declare -gAx STATEDB      #S state database, "pwd//cmd args" : "state cmdhash"

    # LOG keeps "$exitcode $cmdhash $PWD//$*"
    # the tag log keeps the last used tags and tree hashes
    # echo "$1 $BAR_TREE_HASH" >>".bar.s/.tag.log"

    if [[ -f "$STATEDB_LOG" ]]; then
        # replay the log
        local rc
        local cmdhash
        local rest
        while read -r rc cmdhash rest; do
            STATEDB[$rest]="$rc $cmdhash"
        done <"$STATEDB_LOG"
    else
        # new state log
        touch "$STATEDB_LOG"
    fi

    rule CLEANUP: -- "cd '$BAR_TOPLEVEL'; lock_remove '$STATEDB_DIR/.statedb'"
    # TODO:    rule CLEANUP: -- statedb_gc
}

function statedb_cached # cmd args.. - returns the last cached log entry state
{
    local entry="${STATEDB[$PWD//$*]:-}"
    echo "${entry%% *}"
}

function statedb_cmdhash # cmd args.. - returns the hash of $PWD, a command and its args
{
    local entry="${STATEDB[$PWD//$*]:-}"

    if [[ -n "$entry" ]]; then
        entry="${entry#* }"
        echo "${entry%% *}"
    else
        hash_args "$*"
    fi
}

function statedb_replay_stdio #api <cmdhash> - replays the stdout and stderr of a command
{
    debug "$*"
    cat "$STATEDB_DIR/$1.stdout"
    cat "$STATEDB_DIR/$1.stderr" 1>&2
}

function statedb_log # exitcode hash cmd args.. - logs a state
{
    local exitcode="$1"
    local hash="$2"
    shift 2

    trace "STATEDB: $exitcode $* >> $STATEDB_LOG"
    echo "$exitcode $hash $PWD//$*" >>"$STATEDB_LOG"
    STATEDB[$PWD//$*]="$exitcode $hash"
}


# PLANNED: backgrounding git_hook_matches "pre-commit" "pre-merge-commit" && background_schedule && return 0
#                        git_hook_matches "commit-msg" && background_wait && return $(background_result)

function statedb_eval
{
    # shellcheck disable=SC2155
    local cmdhash="$(statedb_cmdhash "$*")"

    # shellcheck disable=SC2155
    local cached_state="$(statedb_cached "$*")"
    case "$cached_state" in
    bg)
        # already scheduled in the background, just return
        info "already bg scheduled $*"
        return 0
        ;;
    0)
        # already run successfully, just return
        info "already success: $*"
        statedb_replay_stdio "$cmdhash"
        return 0
        ;;
    ?*)
        # already run with failure
        info "already failed: $*"
        statedb_replay_stdio "$cmdhash"
        return "$cached_state"
        ;;
    esac

    debug "eval: $*"
    if (
        "$@"
    ) 1> >(tee "$STATEDB_DIR/$cmdhash.stdout") 2> >(tee "$STATEDB_DIR/$cmdhash.stderr" 1>&2 ) ; then
        statedb_log 0 "$cmdhash" "$*"
        return 0
    else
        local rc=$?
        statedb_log "$rc" "$cmdhash" "$*"
        return $rc
    fi
}

# function state_exit #api - exits a state, remove the lock, but keeps the log
# {
#     if [[ -n "$STATE_LOCK" ]]; then
#         unset STATE_LOG
#         unset STATE_DB
#         lock_remove "$STATE_LOCK"
#     fi
# }
# 
