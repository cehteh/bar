#!/bash
#shellcheck disable=SC2016

## standard rule targets where other modules can hook in Undesired std_rules can be renamed or
## deleted in Barf. this is preferred to editing the std_rules file because it allows for
## easier updates of the std_rules file. All these std rules just structure the targets and
## give debug output on the leafs. Actual actions are hooked in by other modules.


### First tier targets: these accumulate the 2nd tier targets, one should add these to MAIN in Barf
### The default Barf file does this already, but it is recommended to customize it.
### Modules can add clauses to these directly but it is preferred to add to the 2nd tier targets
### Note that not all 2nd tier targets are covered here some are meant to be called directly

# a rule that builds the software, documentation and necessary artifacts but will not do any testing.
rule all: build doc

rule lint: lint_sources lint_docs

rule build: fetch_resources build_assets build_libs build_bins

rule tests: test_units test_integrations

rule doc: lint_docs build_docs

rule bench: build_benches benchmark

### Second tier targets: this is where other modules should hook in

# audit for security issues before building
rule audit: -- debug "Running dependency audit..."

# Linting means static analyzer w/o building anything
rule lint_sources: -- debug "Running source lint checks..."
rule lint_docs: -- debug "Running doc lint checks..."

# Fetching resources means downloading or copying resources that are not part of the source tree
rule fetch_resources: -- debug "Fetching resources..."

# Building assets means building the frontend assets
rule build_assets: -- debug "Building assets..."

# building software
rule build_libs: -- debug "Building library..."
rule build_bins: -- debug "Building binaries..."

rule build_tests: build_unit_tests build_integration_tests
rule build_unit_tests: -- debug "Building unit tests"
rule build_integration_tests: -- debug "Building Integration tests"

rule build_docs: -- debug "Building docs..."
rule build_benches: -- debug "Building benches..."
rule build_examples: -- debug "Building examples..."

# run in a loop with a file watcher
rule watch: --conclusive is_entr_installed? -- '
     require entr
     entr_watch "${RULE_ARGS[*]}"
'
rule watch: -- warn "no supported file watcher available"

# Usually versioned files should be source and not generated by any rule. Sometimes one wants
# exceptions from this rule. Like generating a README or CHANGELOG. This can be hooked into
# this rule. This can be run before committing or as part of the commit check where one checks
# for git_is_clean after running generate_versioned. When this failed then the user forgotten
# to update the versioned files.
rule build_versioned_artifacts: -- debug "Generating versioned files..."

# running normal tests
rule test_units: build_unit_tests -- debug "Running unit tests..."
rule test_integrations: build_integration_tests -- debug "Running integration tests..."

# building and running expensive tests
rule test_expensive: -- debug "Running expensive tests..."

# running benchmarks
rule benchmark: -- debug "Running benchmarks..."

### Maintenance and Configuration targets
rule release_patch: -- debug "Making patch release"
rule release_minor: -- debug "Making minor release"
rule release_major: -- debug "Making major release"
rule deploy: -- debug "Deploying project"

rule clean: -- debug "Cleaning build artifacts"
rule reset: -- debug "Resetting into pristine state"

# called as githook (reserve and debug print all non p4 hooks)
rule pre-commit: -- 'debug "called as $RULE_NAME hook"'
rule pre-merge-commit: -- 'debug "called as $RULE_NAME hook"'
rule prepare-commit-msg: -- 'debug "called as $RULE_NAME hook"'
rule commit-msg: -- 'debug "called as $RULE_NAME hook"'
rule applypatch-msg: -- 'debug "called as $RULE_NAME hook"'
rule pre-applypatch: -- 'debug "called as $RULE_NAME hook"'
rule post-applypatch: -- 'debug "called as $RULE_NAME hook"'
rule post-commit: -- 'debug "called as $RULE_NAME hook"'
rule pre-rebase: -- 'debug "called as $RULE_NAME hook"'
rule post-checkout: -- 'debug "called as $RULE_NAME hook"'
rule post-merge: -- 'debug "called as $RULE_NAME hook"'
rule pre-push: -- 'debug "called as $RULE_NAME hook"'
rule pre-receive: -- 'debug "called as $RULE_NAME hook"'
rule update: -- 'debug "called as $RULE_NAME hook"'
rule proc-receive: -- 'debug "called as $RULE_NAME hook"'
rule post-receive: -- 'debug "called as $RULE_NAME hook"'
rule post-update: -- 'debug "called as $RULE_NAME hook"'
rule reference-transaction: -- 'debug "called as $RULE_NAME hook"'
rule push-to-checkout: -- 'debug "called as $RULE_NAME hook"'
rule pre-auto-gc: -- 'debug "called as $RULE_NAME hook"'
rule post-rewrite: -- 'debug "called as $RULE_NAME hook"'
rule sendemail-validate: -- 'debug "called as $RULE_NAME hook"'
rule fsmonitor-watchman: -- 'debug "called as $RULE_NAME hook"'
rule post-index-change: -- 'debug "called as $RULE_NAME hook"'

# Activate maintainer curated hooks and other setup to use bar in this repository
rule activate: -- debug "Activating bar..."

### API extensions
### Some other modules may depend on these for other operations

# create a hash over all source files (non ignored, non generated) in the project.
rule hash_sources: -- debug "Hashing sources"
