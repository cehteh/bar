#!/bash
#shellcheck disable=SC2016

# library for the rule functions

declare -g   BAR_CHECK_LEVEL=0         ## less alerting for check dependencies
declare -g   BAR_RULES_SEALED          ## set to the last rule or 'true' when rules are sealed
declare -gA  BAR_RULES_UNSEALED=([CLEANUP]=true [POSTPROCESS]=true) ## rules exempt from sealing
declare -gAx BAR_RULES                 ## discovered rules as name:"clauseidx.."
declare -gAx BAR_RULES_RESULT          ## result "name args..":rc
declare -gA  BAR_RULES_REVERSE_CLAUSES=([CLEANUP]=true) ## rules with clause evaluated in reverse order
declare -gax BAR_CLAUSES=()            ## clause bodies enumerated
declare -gax BAR_CLAUSE_DEPS=()        ## dependencies for each clause
declare -gax BAR_CLAUSE_STACK=()
declare -ga  BAR_CLAUSE_FLAGS          ## [c]onclusive

function rule () ## [<name>:] [[!]dep[?] [arg]..].. [-- body..] - defines a rule
{
    trace "$*"
    local name="$1"
    if [[ "$name" = *: ]]; then
        name="${name%:}"
        shift
    else
        name=""
    fi

    local deps=()
    local has_body=
    local deps_for_cmd=
    while [[ $# -ne 0 ]]; do
        if [[ "$1" = - ]]; then
            shift
            deps_for_cmd=true
            break
        fi
        if [[ "$1" = -- ]]; then
            shift
            has_body=true
            break
        fi
        deps+=("$1")
        shift
    done

    # name given but no deps, no body, make body default to the rule name
    local body=""
    if [[ "${#deps[*]}" = 0 && "$#" == 0 && -n "$name" ]]; then
        body="$name "'"${RULE_ARGS[@]}"'
    elif [[ -n "$deps_for_cmd" && "$#" == 0 && -n "$name" ]]; then
        rule_exists "$name" && die "rule '$name' already defined"
        body="$name "'"${RULE_ARGS[@]}"'
    elif [[ -z "$name" ]]; then
        # default to MAIN when no rule name is given
        name="MAIN"
    elif [[ -z "$deps_for_cmd" && -z "${BAR_RULES[$name]:-}" ]]  && command -v -- "$name" >/dev/null ; then
        note "defining rule '$name' for existing command"
    fi

    if [[ -v BAR_RULES_SEALED ]]; then
        trace "names ${!BAR_RULES[*]}"
        if [[ -v BAR_RULES[$name] && "$name" != "$BAR_RULES_SEALED" && ! -v BAR_RULES_UNSEALED["$name"] ]]; then
            die "Can not add clause '$name: ${deps[*]}' after rules are sealed"
        else
            BAR_RULES_SEALED="$name"
        fi
    fi

    local ifs="$IFS"
    IFS=$'\n'
    BAR_CLAUSE_DEPS+=("${deps[*]}")
    IFS="$ifs"

    if [[ "$has_body" = true && $# = 0 ]]; then
        BAR_CLAUSES+=("$(cat)")
    else
        BAR_CLAUSES+=("$body$*")
    fi
    BAR_CLAUSE_FLAGS+=("")

    BAR_RULES["$name"]+=" $(( ${#BAR_CLAUSES[@]} - 1))"
}

function newrule ## <name:> ... - creates a new rule with the given name, deletes the existing one
{
    rule_delete "${1%:}"
    rule "$@"
}

function rule_delete
{
    trace "$*"
    local name="$1"
    if [[ -z "$name" ]]; then
        die "rule_delete requires a rule name"
    fi

    if ! rule_exists "$name"; then
        error "rule '$name' does not exist"
        return 1
    fi

    if [[ -n "${BAR_RULES_SEALED:-}" ]]; then
        error "Can not delete rule '$name' after rules are sealed"
        return 1
    fi

    unset "BAR_RULES[$name]"
    unset "BAR_RULES_RESULT[$name]"
}

function rule_rename ## <oldname> <newname> - renames a rule
{
    trace "$*"
    local oldname="$1"
    local newname="$2"

    if [[ -z "$oldname" || -z "$newname" ]]; then
        die "rule_rename requires two rule names"
    fi

    if ! rule_exists "$oldname"; then
        error "rule '$oldname' does not exist"
        return 1
    fi

    if [[ -n "${BAR_RULES_SEALED:-}" ]]; then
        error "Can not rename rule '$oldname' after rules are sealed"
        return 1
    fi

    BAR_RULES["$newname"]="${BAR_RULES[$oldname]}"
    unset "BAR_RULES[$oldname]"
    if [[ -v BAR_RULES_RESULT["$oldname"] ]]; then
        BAR_RULES_RESULT["$newname"]="${BAR_RULES_RESULT[$oldname]}"
        unset "BAR_RULES_RESULT[$oldname]"
    fi
}

function bar_stack_pop
{
    unset "BAR_CLAUSE_STACK[$((${#BAR_CLAUSE_STACK[*]} - 1 ))]"
}

function rule_eval ## <name> [args..]
{
    trace "$*"
    # shellcheck disable=2155
    local rule_id="$(hash_args "$PWD $*")"
    local RULE_NAME="$1"
    shift

    [[ -v BAR_RULES_UNSEALED["$RULE_NAME"] ]] && die "Tried to evaluate unsealed rule: $RULE_NAME"

    # shellcheck disable=2034
    local RULE_ARGS=("$@")
    rule_exists "$RULE_NAME" || rule_autoload "$RULE_NAME"

    if [[ ! "$RULE_NAME" = "always_"* && -v BAR_RULES_RESULT["$rule_id"] ]]; then
        return "${BAR_RULES_RESULT[$rule_id]}"
    fi

    BAR_RULES_RESULT["$rule_id"]="pending"

    local clauses="${BAR_RULES[$RULE_NAME]}"

    if [[ -v BAR_RULES_REVERSE_CLAUSES["$RULE_NAME"] ]]; then
        local rclauses=""
        for n in $clauses; do
            rclauses="$n $rclauses"
        done
        clauses=${rclauses# }
    fi

    BAR_CLAUSE_STACK+=(x)
    local clause
    for clause in $clauses; do
        BAR_CLAUSE_STACK[${#BAR_CLAUSE_STACK[@]}-1]="$clause"
        local skip=
        local dep
        local deps=()
        [[ "${#BAR_CLAUSE_DEPS[$clause]}" -gt 0 ]] && readarray -d $'\n' -t deps <<<"${BAR_CLAUSE_DEPS[$clause]}"

        local dep
        for dep in "${deps[@]}"; do
            local depname="${dep%% *}"
            declare -a depargs
            read -r -a depargs <<<"${dep:${#depname}+1}"
            local check=

            if [[ "$depname" = *"?" ]]; then
                check=true
                depname="${depname%?}"
            fi
            if [[ "$depname" = "!"* ]]; then
                check=negated
                depname="${depname:1}"
            fi
            if [[ "$depname" = *"~" ]]; then
                [[ -z "$check" ]] || die "~ can not be combined with ! or ?"
                check=unconditional
                depname="${depname%?}"
            fi
            [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL+1))

            # shellcheck disable=2155
            local dep_id="$(hash_args "$PWD $depname ${depargs[*]}")"
            local dep_rc="${BAR_RULES_RESULT[$dep_id]:-}"
            if [[ "$dep_id" = "always_"* || -z "$dep_rc" ]]; then
                dep_rc=0
                # shellcheck disable=2086
                rule_eval "$depname" "${depargs[@]}" || dep_rc=$?
            fi

            if [[ "$dep_rc" == pending ]]; then
                die "recursive rule $RULE_NAME: $depname"
            elif [[ "$check" = unconditional ]]; then
                uncond_call "$dep_rc" "$RULE_NAME: $depname~ ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                continue
            elif [[ "$dep_rc" == 0 && "$check" = negated ]]; then
                skip=true
                failure "$RULE_NAME: !$depname ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                break
            elif [[ "$dep_rc" != 0 ]]; then
                if [[ "$check" = true ]]; then
                    failure "$RULE_NAME: $depname? ${depargs[*]}"
                    skip=true
                    [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                    break
                elif [[ "$check" = negated ]]; then
                    success "$RULE_NAME: !$depname ${depargs[*]}"
                    [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                    continue
                fi
                # conclusive fail because of dep failure
                failure "$RULE_NAME: $depname ${depargs[*]}"
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
                BAR_RULES_RESULT["$rule_id"]="$dep_rc"
                bar_stack_pop
                return "$dep_rc"
            else
                if [[ "$check" = true ]]; then
                    success "$RULE_NAME: $depname? ${depargs[*]}"
                elif [[ "$check" = negated ]]; then
                    success "$RULE_NAME: !$depname ${depargs[*]}"
                else
                    success "$RULE_NAME: $depname ${depargs[*]}"
                fi
                [[ -n "$check" ]] && BAR_CHECK_LEVEL=$((BAR_CHECK_LEVEL-1))
            fi
        done

        if [[ "$skip" != true ]]; then
            local rc=0
            eval "${BAR_CLAUSES[$clause]}" || rc=$?
            if [[ "${BAR_CLAUSE_FLAGS[$clause]}" = *c* ]]; then
                BAR_RULES_RESULT["$rule_id"]=$rc
                bar_stack_pop
                return "$rc"
            fi
            if [[ "$rc" != 0 ]]; then
                BAR_RULES_RESULT["$rule_id"]=$rc
                bar_stack_pop
                return "$rc"
            fi
        fi
    done

    bar_stack_pop
    BAR_RULES_RESULT["$rule_id"]=0
}

function rule_exists ## <name> - checks if a rule is defined
{
    [[ -v BAR_RULES[$1] ]]
}

function rule_list ## [pattern] - lists all loaded rules or rules matching pattern
{
    local rule
    for rule in $(tr ' ' '\n' <<<"${!BAR_RULES[@]}" | sort); do
        # shellcheck disable=2053
        if [[ "$rule" = ${1:-*} ]]; then
            local clause
            for clause in ${BAR_RULES[$rule]}; do
                local dep
                local deps
                deps=""
                while read -r dep; do
                    [[ -n "$deps" ]] && deps+=" "
                    if [[ "$dep" = *" "* ]]; then
                        deps+="'$dep'"
                    else
                        deps+="$dep"
                    fi
                done <<<"${BAR_CLAUSE_DEPS[$clause]}"
                echo -n "$rule: $deps"
                if [[ -n "${BAR_CLAUSES[$clause]}" ]]; then
                    [[ -n "$deps" ]] && echo -n " "
                    echo -e "-- '${BAR_CLAUSES[$clause]}'"
                else
                    echo
                fi
            done
        fi
        echo
    done | less -SR
}

function conclusive ## as dependency makes a clause result conclusive for the rule, when not skipped, no more clauses will be tried
{
    [[ "$(( ${#BAR_CLAUSE_STACK[*]} ))" -gt 1 ]] || die "conclusive must be used as dependency"
    local parent_clause="${BAR_CLAUSE_STACK[$(( ${#BAR_CLAUSE_STACK[*]} - 2 ))]}"

    if [[ "${BAR_CLAUSE_FLAGS[$parent_clause]}" != *c*  ]] ; then
        BAR_CLAUSE_FLAGS["$parent_clause"]+="c"
    fi
}

