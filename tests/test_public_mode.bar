#!/usr/bin/env bar
# -*- mode: sh; sh-shell: bash -*-
# vim: set ft=bash:
# shellcheck shell=bash

### Test --public mode for __bar_parse_file

# Source the completion script before tests
rule test_public_mode: 'require contrib/bar_complete'

function public_mode_test_case_1 ## - Test parsing example without --public (only documented rules)
{
    __bar_rules=()
    __bar_functions=()
    __bar_parse_file "example"
    [ ${#__bar_rules[@]} -eq 0 ]
}

function public_mode_test_case_2 ## - Test parsing example with --public (all rules)
{
    __bar_rules=()
    __bar_functions=()
    __bar_parse_file --public "example"
    [ ${#__bar_rules[@]} -gt 20 ]
}

function public_mode_test_case_3 ## - Test parsing Bar.d/git_rules without --public
{
    __bar_rules=()
    __bar_functions=()
    if [ -f "Bar.d/git_rules" ]; then
        __bar_parse_file "Bar.d/git_rules"
        [ ${#__bar_rules[@]} -gt 0 ]
    else
        # Skip if file doesn't exist
        return 0
    fi
}

function public_mode_test_case_4 ## - Test completion after specifying rulefile
{
    local nounset_was_on=
    [[ $- == *u* ]] && nounset_was_on=1 && set +u
    
    COMP_WORDS=(bar "example" "")
    COMP_CWORD=2
    _bar_complete
    
    local has_example_ok=false
    local has_example_fail=false
    local comp
    for comp in "${COMPREPLY[@]}"; do
        [[ "$comp" == "example_ok" ]] && has_example_ok=true
        [[ "$comp" == "example_fail" ]] && has_example_fail=true
    done
    
    [[ -n "$nounset_was_on" ]] && set -u
    
    [ "$has_example_ok" = true ] && [ "$has_example_fail" = true ]
}

function public_mode_test_case_5 ## - Test default rulefile should use --public
{
    __bar_scan_files bar
    [ ${#__bar_rules[@]} -gt 0 ]
}

## Run all public mode tests
rule test_public_mode: -- public_mode_test_case_1
rule test_public_mode: -- public_mode_test_case_2
rule test_public_mode: -- public_mode_test_case_3
rule test_public_mode: -- public_mode_test_case_4
rule test_public_mode: -- public_mode_test_case_5
