#!/usr/bin/env bar
# -*- mode: sh; sh-shell: bash -*-
# vim: set ft=bash:
# shellcheck shell=bash

### Test external completers and literal punctuation handling

rule test_ext_completers: 'require contrib/bar_complete'

rule test_ext_completers: -- '__bar_init_completion_registry'

# Mock external completer function for testing
function test_ext_complete ## - Mock external completer
{
    echo "option1"
    echo "option2"
    echo "option3"
}

# Mock bar function for testing
function bar ## - Mock bar command
{
    if [[ "$1" == "--bare" && "$2" == "test_ext_complete" ]]; then
        echo "result1"
        echo "result2"
        return 0
    fi
    return 1
}

function test_external_completer_setup ## - Test external completer setup
{
    
    # Add the external completer to registry
    __bar_protoregistry["testproto"]="ext test_ext_complete"
    
    # Get the expanded completer
    local completer
    completer=$(__bar_get_completer "" "testproto")
    echo "  Expanded completer: $completer"
    
    if [[ "$completer" == "__bar_comp_ext test_ext_complete" ]]; then
        return 0
    else
        return 1
    fi
}

function test_calling_external_completer ## - Test calling external completer
{
    
    local results result_count
    results=$(__bar_comp_ext "test_ext_complete" "res")
    result_count=$(echo "$results" | wc -l)
    
    if [[ $result_count -ge 2 ]]; then
        return 0
    else
        return 1
    fi
}

function test_literal_punctuation_parsing ## - Test literal punctuation in prototypes
{
    
    local status=0
    
    # Test parsing of <+toolchain>
    echo "  Testing <+toolchain> parsing..."
    local protos proto_array
    protos=$(_bar_parse_protos "<+toolchain>")
    proto_array=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && proto_array+=("$line")
    done <<< "$protos"
    
    echo "  Parsed prototypes: ${proto_array[*]}"
    if [[ "${proto_array[0]}" == "+toolchain" ]]; then
        true
    else
        status=1
    fi
    
    # Test parsing of <rule:>
    echo ""
    echo "  Testing <rule:> parsing..."
    protos=$(_bar_parse_protos "<rule:>")
    proto_array=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && proto_array+=("$line")
    done <<< "$protos"
    
    echo "  Parsed prototypes: ${proto_array[*]}"
    if [[ "${proto_array[0]}" == "rule:" ]]; then
        true
    else
        status=1
    fi
    
    # Test parsing of [+toolchain]
    echo ""
    echo "  Testing [+toolchain] parsing..."
    protos=$(_bar_parse_protos "[+toolchain]")
    proto_array=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && proto_array+=("$line")
    done <<< "$protos"
    
    echo "  Parsed prototypes: ${proto_array[*]}"
    if [[ "${proto_array[0]}" == "[+toolchain]" ]]; then
        true
    else
        status=1
    fi
    
    return $status
}

function test_literal_punctuation_extraction ## - Test literal punctuation extraction
{
    
    local status=0
    local nounset_was_on=
    [[ $- == *u* ]] && nounset_was_on=1 && set +u
    
    # Test _bar_extract_literal_punct with '+toolchain'
    echo "  Testing _bar_extract_literal_punct with '+toolchain'..."
    local result result_array
    result=$(_bar_extract_literal_punct "+toolchain")
    result_array=()
    while IFS= read -r line; do
        result_array+=("$line")
    done <<< "$result"
    
    if [[ "${result_array[0]}" == "toolchain" && "${result_array[1]}" == "+" && "${result_array[2]:-}" == "" ]]; then
        true
    else
        echo "  Got: proto='${result_array[0]}', prefix='${result_array[1]}', suffix='${result_array[2]:-}'"
        status=1
    fi
    
    # Test with 'rule:'
    echo "  Testing _bar_extract_literal_punct with 'rule:'..."
    result=$(_bar_extract_literal_punct "rule:")
    result_array=()
    while IFS= read -r line; do
        result_array+=("$line")
    done <<< "$result"
    
    if [[ "${result_array[0]}" == "rule" && "${result_array[1]:-}" == "" && "${result_array[2]}" == ":" ]]; then
        true
    else
        echo "  Got: proto='${result_array[0]}', prefix='${result_array[1]:-}', suffix='${result_array[2]}'"
        status=1
    fi
    
    # Test with '--flag'
    echo "  Testing _bar_extract_literal_punct with '--flag'..."
    result=$(_bar_extract_literal_punct "--flag")
    result_array=()
    while IFS= read -r line; do
        result_array+=("$line")
    done <<< "$result"
    
    if [[ "${result_array[0]}" == "--flag" && "${result_array[1]:-}" == "" && "${result_array[2]:-}" == "" ]]; then
        true
    else
        echo "  Got: proto='${result_array[0]}', prefix='${result_array[1]:-}', suffix='${result_array[2]:-}'"
        status=1
    fi
    
    # Test with 'name..'
    echo "  Testing _bar_extract_literal_punct with 'name..'..."
    result=$(_bar_extract_literal_punct "name..")
    result_array=()
    while IFS= read -r line; do
        result_array+=("$line")
    done <<< "$result"
    
    if [[ "${result_array[0]}" == "name.." && "${result_array[1]:-}" == "" && "${result_array[2]:-}" == "" ]]; then
        true
    else
        echo "  Got: proto='${result_array[0]}', prefix='${result_array[1]:-}', suffix='${result_array[2]:-}'"
        status=1
    fi
    
    [[ -n "$nounset_was_on" ]] && set -u
    return $status
}

## Run all external completer tests
rule test_ext_completers: -- test_external_completer_setup
rule test_ext_completers: -- test_calling_external_completer
rule test_ext_completers: -- test_literal_punctuation_parsing
rule test_ext_completers: -- test_literal_punctuation_extraction
