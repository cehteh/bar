#!/bash
# shellcheck disable=2016

# This file shows and tests some features
# You can run this example with './bar example [rule]'

# Add a clause to 'MAIN'
rule -- echo "Example begin"

# Different ways to define rule bodies
rule example_ok: -- echo inline
rule example_ok: -- '
    echo inline quoted
'

rule example_ok: -- <<<"echo herestring"
rule example_ok: -- <<EOF
    echo heredoc
EOF

# Make a rule that fails
rule example_fail: -- false

# functions and other commands can be used as rules
function example
{
    echo "I am example called with $*"
}

# add a tests rule with 3 clauses
rule tests: example_ok? !example_fail 'example "argument"' -- echo "example_ok success"
rule tests: !example_ok -- echo "This is never called, but test still passes"
rule tests: example_fail~ -- echo "This unconditionally called even if example_fail fails"
rule tests: example_fail? -- echo "This is also never called"

# add tests to MAIN
rule tests

rule POSTPROCESS: -- echo "at last"
rule CLEANUP: -- echo "finally"
rule CLEANUP: -- echo "before finally, because CLEANUP clauses are evaluated in reverse order"

# clauses can be conclusive
rule test_conclusive: --conclusive example_fail? -- echo "This is skipped"
rule test_conclusive: --conclusive !example_fail -- echo "This is conclusive"
rule test_conclusive: -- echo "This is not reached"

rule test_conclusive

# flags add up
rule --always always: -- echo "always called second"
rule --reverse always: -- echo "always called first"

rule test_always: always always always
rule test_always

rule test_memodb: memodb_init -- debug "Memo test begin"
rule test_memodb: memotest1 memotest2 memotest3

rule test_memodb

rule memotest1: -- memodb_eval echo "memotest"
rule memotest2: -- memodb_eval echo "memotest"
rule memotest3: -- memodb_eval echo "memotest"

# run this first
rule test_background_schedule: 'memodb_schedule echo "run in background"' -- '
     # memodb_schedule/result can be called as function or evaluated as rule
     # wait here to simulate some longer work
     memodb_schedule sleep 3
'

rule test_background_schedule

# then this (manually)
rule test_background_result: 'memodb_result echo "run in background"'

# These two must panic
rule recursive: recursive
rule --always always_recursive: always_recursive

# the ?? prefix is a implied 'rule_exists? <dep>' it can be combined with other operators
rule test_hooks: !failing_hook??? - echo "failing hook exists failed"
rule test_hooks: nonexist_hook?? - echo "unreached: no_failing_hook does not exist"
rule test_hooks: succeeding_hook??? - echo "success"
rule failing_hook: -- false
rule succeeding_hook: -- true

rule test_hooks

# clauses in a rule can be disjunctive
rule --disjunct test_disjunct: -- false
rule test_disjunct: -- echo "true"
rule test_disjunct: -- false

rule test_disjunct

# Scalar variables can be clause-local

# shellcheck disable=2034
variable=outer

rule test_clause_local: -- '
     variable=global
     echo "1.1: $variable"
'
rule test_clause_local: -- '
     # still global
     echo "1.2: $variable"
'
rule test_clause_local: 'clause_local variable' -- '
     variable=as_dep
     echo "2: $variable"
'
rule test_clause_local: -- '
     clause_local variable
     variable=local
     echo "3: $variable"
'
rule test_clause_local: 'clause_local variable=assigned' -- '
     echo "4: $variable"
'
rule test_clause_local: -- '
     # back to global
     echo "5: $variable"
'

rule test_clause_local

# manual test for color codes/tty rendering
rule test_ttylib: 'clause_local BAR_VERBOSITY_LEVEL BAR_CHECK_LEVEL' -- '
     BAR_VERBOSITY_LEVEL=6
     #DBG DBG
     #die PANIC
     echo "${TTYERR[R_B]:-}PANIC:${TTYERR[n]:-} panic" >&2
     error error
     warn warn
     note note
     info info
     debug debug
     trace trace
     uncond_call 0 uncond_ok
     uncond_call 1 uncond_fail
     progress progress; echo >&2
     success success
     failure failure
     BAR_CHECK_LEVEL+=1
     progress check_progress; echo >&2
     success check_success
     failure check_failure
'
