#!/bash
# shellcheck disable=2016

# This file shows and tests some features
# It also serves as testsuite for bar
# You can run this example with './bar example [rule]'

# Add a clause to 'MAIN'
rule -- echo "Example begin"

# Different ways to define rule bodies
rule example_ok: -- echo inline
rule example_ok: -- '
    echo inline quoted
'

rule example_ok: -- <<<"echo herestring"
rule example_ok: -- <<EOF
    echo heredoc
EOF

# Make a rule that fails
rule example_fail: -- false

# functions and other commands can be used as rules
function example
{
    echo "I am example called with $*"
}

require help

function example_benchmark ## <count> <command> [args..] - Benchmark command invocations
{
     local count=$1
     shift || true

     if [[ -z "$count" || ! "$count" =~ ^[0-9]+$ ]]; then
          printf 'benchmark: count must be a positive integer\n' >&2
          return 1
     fi

     local -i iterations=$count
     if (( iterations <= 0 )); then
          printf 'benchmark: count must be greater than zero\n' >&2
          return 1
     fi

     if (( $# == 0 )); then
          printf 'benchmark: missing command to execute\n' >&2
          return 1
     fi

          local -a cmd=("$@")
          local start_ns end_ns elapsed_ns avg_ns i

               start_ns=$(date +%s%N)
          for ((i = 0; i < iterations; i++)); do
               "${cmd[@]}" >/dev/null 2>&1 || return 1
          done
          end_ns=$(date +%s%N)

               elapsed_ns=$(( 10#$end_ns - 10#$start_ns ))
     avg_ns=$(( elapsed_ns / iterations ))

          printf 'iterations=%d total_ns=%d avg_ns=%d\n' "$iterations" "$elapsed_ns" "$avg_ns"
}

# add a tests rule with 3 clauses
rule tests: example_ok? !example_fail 'example "argument"' -- echo "example_ok success"
rule tests: !example_ok -- echo "This is never called, but test still passes"
rule tests: example_fail~ -- echo "This unconditionally called even if example_fail fails"
rule tests: example_fail? -- echo "This is also never called"

# add tests to MAIN
rule tests

rule POSTPROCESS: -- echo "at last"
rule CLEANUP: -- echo "finally"
rule CLEANUP: -- echo "before finally, because CLEANUP clauses are evaluated in reverse order"

# clauses can be conclusive
rule test_conclusive: --conclusive example_fail? -- echo "This is skipped"
rule test_conclusive: --conclusive !example_fail -- echo "This is conclusive"
rule test_conclusive: -- echo "This is not reached"

rule test_conclusive

# flags add up
rule --always always: -- echo "always called second"
rule --reverse always: -- echo "always called first"

rule test_always: always always always
rule test_always

rule test_memodb: memodb_init -- debug "Memo test begin"
rule test_memodb: memotest1 memotest2 memotest3

rule test_memodb

rule memotest1: -- memodb_eval echo "memotest"
rule memotest2: -- memodb_eval echo "memotest"
rule memotest3: -- memodb_eval echo "memotest"

# run this first
rule test_background_schedule: 'memodb_schedule echo "run in background"' -- '
     # memodb_schedule/result can be called as function or evaluated as rule
     # wait here to simulate some longer work
     memodb_schedule sleep 3
'

rule test_background_schedule

# then this (manually)
rule test_background_result: 'memodb_result echo "run in background"'

# The following must panic
rule recursive: recursive
rule --always always_recursive: always_recursive
rule self_modifying: -- '
     rule self_modifying: -- DBG "can not add clause to executing rule"
'

# the ?? prefix is a implied 'rule_exists? <dep>' it can be combined with other operators
rule test_hooks: !failing_hook??? - echo "failing hook exists failed"
rule test_hooks: nonexist_hook?? - echo "unreached: no_failing_hook does not exist"
rule test_hooks: succeeding_hook??? - echo "success"
rule test_hooks: failing_hook~?? - echo "always"
rule failing_hook: -- false
rule succeeding_hook: -- true

rule test_hooks

# clauses in a rule can be disjunctive
rule --disjunct test_disjunct: -- false
rule test_disjunct: -- echo "true"
rule test_disjunct: -- false

rule test_disjunct

# Scalar variables can be clause-local

# shellcheck disable=2034
variable=outer

rule test_clause_local: -- '
     variable=global
     echo "1.1: $variable"
'
rule test_clause_local: -- '
     # still global
     echo "1.2: $variable"
'
rule test_clause_local: 'clause_local variable' -- '
     variable=as_dep
     echo "2: $variable"
'
rule test_clause_local: -- '
     clause_local variable
     variable=local
     echo "3: $variable"
'
rule test_clause_local: 'clause_local variable=assigned' -- '
     echo "4: $variable"
'
rule test_clause_local: -- '
     # back to global
     echo "5: $variable"
'

rule test_clause_local

# manual test for color codes/tty rendering
rule test_ttylib: 'clause_local BAR_VERBOSITY_LEVEL BAR_CHECK_LEVEL' -- '
     BAR_VERBOSITY_LEVEL=6
     #DBG DBG
     #die PANIC
     echo "${TTYERR[R_B]:-}PANIC:${TTYERR[n]:-} panic" >&2
     error error
     warn warn
     note note
     info info
     debug debug
     trace trace
     uncond_call 0 uncond_ok
     uncond_call 1 uncond_fail
     BAR_CHECK_LEVEL=0 progress progress; echo >&2
     BAR_CHECK_LEVEL=0 success success
     BAR_CHECK_LEVEL=0 failure failure
     BAR_CHECK_LEVEL=2 progress check_progress; echo >&2
     BAR_CHECK_LEVEL=3 success check_success
     BAR_CHECK_LEVEL=4 failure check_failure
'

# rules can be permanently disabled
rule disabled_rule: -- die "must not happen"
rule --disable disabled_rule:

rule disabled_rule

# require with slash loads from arbitrary locations
rule test_hello: 'require contrib/hello.sh'
# hello is loaded only once, this wont show up
rule test_hello: 'require ./contrib/hello.sh'

rule test_hello

require semver_lib # PLANNED: mv semver_lib semver

rule test_semver_validate: 'semver_validate 0.0.1'
rule test_semver_validate: 'semver_validate 1.0.0'
rule test_semver_validate: 'semver_validate 10.20.30-alpha'
rule test_semver_validate: 'semver_validate 1.2.3-beta.1'

rule test_semver_validate

rule test_semver_validate_invalid: 'semver_validate? 1.2' -- false
rule test_semver_validate_invalid: 'semver_validate? a.b.c' -- false
rule test_semver_validate_invalid: 'semver_validate? 1.2.3@beta' -- false

rule test_semver_validate_invalid

rule test_semver_is_patch: 'semver_is_patch 1.2.3+beta'
rule test_semver_is_patch: 'semver_is_patch? 1.2.0+beta' -- false

rule test_semver_is_patch

function assert_semver_inc
{
    local ver=$1 part=$2 expected=$3
    local result
    echo "increment $2: $1 -> $3"
    result=$(semver_increment "$ver" "$part")
    [[ "$result" == "$expected" ]]
}

rule test_semver_inc: 'assert_semver_inc 1.2.3-alpha.5 release 1.2.3'

rule test_semver_inc: 'assert_semver_inc 0.2.3 major 1.0.0'
rule test_semver_inc: 'assert_semver_inc 1.2.3 major 2.0.0'

rule test_semver_inc: 'assert_semver_inc 0.2.3 majorpre1x 0.3.0'
rule test_semver_inc: 'assert_semver_inc 1.2.3 majorpre1x 2.0.0'

rule test_semver_inc: 'assert_semver_inc 0.2.3 minor 0.3.0'
rule test_semver_inc: 'assert_semver_inc 1.2.3 minor 1.3.0'

rule test_semver_inc: 'assert_semver_inc 0.2.3 patch 0.2.4'
rule test_semver_inc: 'assert_semver_inc 1.2.99 patch 1.2.100'

rule test_semver_inc

rule test_semver_cmp: 'semver_lt 1.2.3 1.2.4'
rule test_semver_cmp: 'semver_lt? 1.2.3 1.2.3' -- false
rule test_semver_cmp: 'semver_lt? 1.2.4 1.2.3' -- false
rule test_semver_cmp: 'semver_lt 1.2.3-alpha 1.2.3'
rule test_semver_cmp: 'semver_le 1.2.3 1.2.4'
rule test_semver_cmp: 'semver_le 1.2.3 1.2.3'
rule test_semver_cmp: 'semver_le 1.2.3-alpha 1.2.3'
rule test_semver_cmp: 'semver_eq 1.2.3 1.2.3'
rule test_semver_cmp: 'semver_eq? 1.2.3 1.2.4' -- false
rule test_semver_cmp: 'semver_eq 1.2.3-alpha 1.2.3-alpha'
rule test_semver_cmp: 'semver_ge 1.2.4 1.2.3'
rule test_semver_cmp: 'semver_ge 1.2.3 1.2.3'
rule test_semver_cmp: 'semver_ge 1.2.3 1.2.3-alpha'
rule test_semver_cmp: 'semver_gt 1.2.4 1.2.3'
rule test_semver_cmp: 'semver_gt? 1.2.3 1.2.3' -- false
rule test_semver_cmp: 'semver_gt 1.2.3 1.2.3-alpha'

rule test_semver_cmp

# test bare rules (BAR_VERBOSITY_LEVEL=4 bar example test_bare)

rule --bare test_bare: -- echo "This is bare"

rule test_bare
