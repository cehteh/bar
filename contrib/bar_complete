#!/bin/bash
# Bash completion script for bar, please and ./bar
#
# This script parses documented rules and functions (those with ## doc comments)
# and provides intelligent completion.
#
# Installation:
#   Link this file to ~/.bash_completion/bar_complete or source it in your .bashrc
#   Or run: bar init_install (which will create the symlink automatically)
#
# Usage:
#   After installation, bash completion will work for:
#   - bar <TAB>       - completes rulefiles, rules, and functions
#   - please <TAB>    - completes rulefiles, rules, and functions
#   - ./bar <TAB>     - completes rulefiles, rules, and functions

# Debug logging function - set BAR_COMPLETE_DEBUG=1 to enable
_bar_complete_dbg()
{
    [[ -n "$BAR_COMPLETE_DEBUG" ]] && echo "$*" >&2
}

# Data structures for completion
# _bar_completion_rules: array storing rule names
declare -ga _bar_completion_rules=()

# _bar_completion_functions: array storing function names
declare -ga _bar_completion_functions=()

# _bar_completion_rulefiles: array storing rulefile names
declare -ga _bar_completion_rulefiles=()

# Parameter completion data structures
# _bar_completion_func_params: associative array "funcname" -> "param_list"
# param_list is space-separated list of parameters like: "[--opt] <file> [output]"
declare -gA _bar_completion_func_params=()

# _bar_completion_rule_params: associative array "rulename" -> "param_list"
declare -gA _bar_completion_rule_params=()

# _bar_completion_func_module: associative array "funcname" -> "module"
# Tracks which module a function came from for module-specific completers
declare -gA _bar_completion_func_module=()

# _bar_completion_rule_module: associative array "rulename" -> "module"  
# Tracks which module a rule came from for module-specific completers
declare -gA _bar_completion_rule_module=()

# _bar_complete_protoregistry: associative array "prototype" -> "completer_function [predicates]"
# Maps parameter prototypes to their completion functions
# Examples: registry["file"]="file"
#           registry["cargo@toolchain"]="ext cargo_toolchain_complete"
declare -gA _bar_complete_protoregistry=()

# _bar_completion_actions: associative array "prototype" -> "action_function"
# Maps prototypes to actions that should be executed when that prototype is matched
# Examples: actions["rulefile"]="_bar_action_parse_rulefile"
declare -gA _bar_completion_actions=()

# _bar_completion_extcomplete_cache: associative array "completer_name" -> "cached_results"
# Cache for external completion results
declare -gA _bar_completion_extcomplete_cache=()

# _bar_completion_module_completers: indexed array storing module-specific completers
# Format: "module:completer_name"
declare -ga _bar_completion_module_completers=()

# Helper: Find free slot in an array or append
# Kept for future use, currently not actively used
_bar_alloc_slot()
{
    local freelist_var="$1"
    local array_var="$2"
    
    # Get the freelist value
    local freelist="${!freelist_var}"
    
    if [[ -n "$freelist" ]]; then
        local slot
        read -r slot freelist <<< "$freelist"
        # Update the freelist variable
        printf -v "$freelist_var" '%s' "$freelist"
        echo "$slot"
    else
        # Get array size using nameref
        local -n arr="$array_var"
        echo "${#arr[@]}"
    fi
}

# Helper: Free a slot in an array
# Kept for future use, currently not actively used
_bar_free_slot()
{
    local freelist_var="$1"
    local array_var="$2"
    local slot="$3"

    # Add slot to freelist
    local freelist="${!freelist_var}"
    printf -v "$freelist_var" '%s' "$slot $freelist"

    # Clear the array entry
    local -n arr="$array_var"
    arr[slot]=""
}

# Generic completion functions

# Apply predicate filters to completions
_bar_apply_predicates()
{
    local -a predicates=("$@")
    local item
    
    # Read items from stdin
    while IFS= read -r item; do
        local pass=true
        local pred
        for pred in "${predicates[@]}"; do
            # Call predicate function to test item
            if ! "_bar_complete_pred_${pred}" "$item" 2>/dev/null; then
                pass=false
                break
            fi
        done
        [[ $pass == true ]] && echo "$item"
    done
}

# Predicate: file exists
_bar_complete_pred_existing()
{
    [[ -e "$1" ]]
}

# Predicate: file does not exist
_bar_complete_pred_nonexisting()
{
    [[ ! -e "$1" ]]
}

# Predicate: is in local directory
_bar_complete_pred_local()
{
    [[ "$1" != */* ]]
}

# Predicate: is a rulefile
# Checks if file is readable and has a shebang AND contains rule or function statements
_bar_complete_pred_rulefile()
{
    if [[ -f "$1" && -r "$1" ]]; then
        # Check for shebang in first line AND rule/function statements
        local first_line
        read -r first_line < "$1" 2>/dev/null
        if [[ "$first_line" != '#!/'* ]]; then
            return 1
        fi
        grep -qE '^(rule|function)[[:space:]]' "$1" 2>/dev/null
    else
        return 1
    fi
}

# Complete file paths
_bar_complete_comp_file()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    # Use bash's built-in file completion
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -f -- "$cur" | _bar_apply_predicates "${predicates[@]}"
    else
        compgen -f -- "$cur"
    fi
}

# Complete directory paths
_bar_complete_comp_directory()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -d -- "$cur" | _bar_apply_predicates "${predicates[@]}"
    else
        compgen -d -- "$cur"
    fi
}

# Complete any path (file or directory)
_bar_complete_comp_path()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -f -- "$cur" | _bar_apply_predicates "${predicates[@]}"
    else
        compgen -f -- "$cur"
    fi
}

# Complete with existing rule names
_bar_complete_comp_rule()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    # Get all rules
    local -a rules=()
    for rule in "${_bar_completion_rules[@]}"; do
        if [[ "$rule" == "$cur"* ]]; then
            rules+=("$rule")
        fi
    done
    
    # Apply predicates if specified
    if [[ ${#predicates[@]} -gt 0 ]]; then
        if [[ ${#rules[@]} -gt 0 ]]; then
            printf '%s\n' "${rules[@]}" | _bar_apply_predicates "${predicates[@]}"
        fi
    else
        if [[ ${#rules[@]} -gt 0 ]]; then
            printf '%s\n' "${rules[@]}"
        fi
    fi
}

# Complete with rule or function names (no system commands)
_bar_complete_comp_rule_or_function()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    # Collect all candidates
    local -a candidates=()
    
    # Get rules
    for rule in "${_bar_completion_rules[@]}"; do
        if [[ "$rule" == "$cur"* ]]; then
            candidates+=("$rule")
        fi
    done
    
    # Get functions
    for func in "${_bar_completion_functions[@]}"; do
        if [[ "$func" == "$cur"* ]]; then
            candidates+=("$func")
        fi
    done
    
    # Apply predicates if specified
    if [[ ${#predicates[@]} -gt 0 ]]; then
        if [[ ${#candidates[@]} -gt 0 ]]; then
            printf '%s\n' "${candidates[@]}" | _bar_apply_predicates "${predicates[@]}"
        fi
    else
        if [[ ${#candidates[@]} -gt 0 ]]; then
            printf '%s\n' "${candidates[@]}"
        fi
    fi
}

# Complete with command/function names
_bar_complete_comp_command()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    # Complete with functions and commands in PATH
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -c -- "$cur" | _bar_apply_predicates "${predicates[@]}"
    else
        compgen -c -- "$cur"
    fi
}

# Complete with command, function, or rule names
_bar_complete_comp_command_or_rule()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    # Collect all candidates
    local -a candidates=()
    
    # Get rules
    for rule in "${_bar_completion_rules[@]}"; do
        if [[ "$rule" == "$cur"* ]]; then
            candidates+=("$rule")
        fi
    done
    
    # Get functions
    for func in "${_bar_completion_functions[@]}"; do
        if [[ "$func" == "$cur"* ]]; then
            candidates+=("$func")
        fi
    done
    
    # Get commands from PATH
    while IFS= read -r cmd; do
        candidates+=("$cmd")
    done < <(compgen -c -- "$cur")
    
    # Remove duplicates and apply predicates
    if [[ ${#predicates[@]} -gt 0 ]]; then
        if [[ ${#candidates[@]} -gt 0 ]]; then
            printf '%s\n' "${candidates[@]}" | sort -u | _bar_apply_predicates "${predicates[@]}"
        fi
    else
        if [[ ${#candidates[@]} -gt 0 ]]; then
            printf '%s\n' "${candidates[@]}" | sort -u
        fi
    fi
}

# Complete with a literal keyword
# This completer is bound to a prototype and completes to that literal
_bar_complete_comp_literal()
{
    local cur="$1"
    local literal="$2"  # The literal keyword to complete
    
    # If the literal starts with the current prefix, offer it as completion
    if [[ "$literal" == "$cur"* ]]; then
        echo "$literal"
    fi
}

# External completer - calls bar --bare <completer_name> to get completions
_bar_complete_ext()
{
    local completer_name="$1"
    local cur="$2"
    
    # Check cache first
    if [[ -v _bar_completion_extcomplete_cache["$completer_name"] ]]; then
        local cached="${_bar_completion_extcomplete_cache[$completer_name]}"
        # Filter cached results by current prefix
        local result
        for result in $cached; do
            if [[ "$result" == "$cur"* ]]; then
                echo "$result"
            fi
        done
        return 0
    fi
    
    # Call bar --bare to get completions
    local results
    if results=$(bar --bare "$completer_name" 2>/dev/null); then
        # Cache the results
        _bar_completion_extcomplete_cache[$completer_name]="$results"
        # Filter and return
        local result
        for result in $results; do
            if [[ "$result" == "$cur"* ]]; then
                echo "$result"
            fi
        done
    fi
}

# Initialize default completion registry
_bar_init_completion_registry()
{
    # Generic completers
    _bar_complete_protoregistry[file]="file"
    _bar_complete_protoregistry[directory]="directory"
    _bar_complete_protoregistry[path]="path"
    _bar_complete_protoregistry[rule]="rule_or_function"
    _bar_complete_protoregistry[command]="command"
    _bar_complete_protoregistry[command_or_rule]="command_or_rule"
    
    # Rulefile completer - uses file completer with rulefile predicate
    _bar_complete_protoregistry[rulefile]="file rulefile"
    
    # Literal completers - register specific literals
    _bar_complete_protoregistry[--bare]="literal --bare"
    
    # Arguments completer - default file completion
    _bar_complete_protoregistry[arguments]="file"
    
    # Add module-specific completers (populated during file parsing)
}

# Parse parameter spec into protos array
# Input: param_spec like "[--opt] <file> [output]"
# Output: protos array with parsed prototypes
_bar_parse_protos()
{
    local param_spec="$1"
    local -a protos=()
    
    # Tokenize the parameter spec
    # This is a simplified parser for the formal parameter syntax
    local in_bracket=false
    local in_angle=false
    local current_token=""
    local is_optional=false
    
    local i
    for ((i=0; i<${#param_spec}; i++)); do
        local char="${param_spec:$i:1}"
        
        case "$char" in
            '[')
                in_bracket=true
                is_optional=true
                ;;
            '<')
                in_angle=true
                current_token=""
                ;;
            ']'|'>')
                if [[ -n "$current_token" ]]; then
                    # Check for .. suffix
                    local repeating=false
                    if [[ "${param_spec:$((i+1)):2}" == ".." ]]; then
                        repeating=true
                        i=$((i+2))
                    fi
                    
                    # Store the prototype
                    local proto_entry="$current_token"
                    [[ $is_optional == true ]] && proto_entry="[$proto_entry]"
                    [[ $repeating == true ]] && proto_entry="${proto_entry}.."
                    protos+=("$proto_entry")
                    current_token=""
                fi
                in_bracket=false
                in_angle=false
                is_optional=false
                ;;
            ' '|$'\t')
                # Space separates tokens
                if [[ -n "$current_token" && $in_bracket == false && $in_angle == false ]]; then
                    # Literal word
                    protos+=("$current_token")
                    current_token=""
                fi
                ;;
            *)
                current_token="${current_token}${char}"
                ;;
        esac
    done
    
    # Handle any remaining token
    if [[ -n "$current_token" ]]; then
        protos+=("$current_token")
    fi
    
    # Add empty terminator
    protos+=("")
    
    printf '%s\n' "${protos[@]}"
}

# Get completer for a prototype
# Looks up: module@proto (if module known), then func@proto, then proto
# Returns expanded completer spec (with _bar_complete_comp_ or _bar_complete_ext prefix)
_bar_get_completer()
{
    local func_or_rule="$1"
    local proto="$2"
    local spec=""
    
    # Try to get module for this func/rule
    local module=""
    if [[ -v _bar_completion_func_module["$func_or_rule"] ]]; then
        module="${_bar_completion_func_module[$func_or_rule]}"
    elif [[ -v _bar_completion_rule_module["$func_or_rule"] ]]; then
        module="${_bar_completion_rule_module[$func_or_rule]}"
    fi
    
    # Try module@proto lookup first if we know the module
    if [[ -n "$module" ]]; then
        local key="${module}@${proto}"
        if [[ -v _bar_complete_protoregistry["$key"] ]]; then
            spec="${_bar_complete_protoregistry[$key]}"
        fi
    fi
    
    # If not found, try hierarchical lookup: func@proto
    if [[ -z "$spec" && -n "$func_or_rule" ]]; then
        local key="${func_or_rule}@${proto}"
        if [[ -v _bar_complete_protoregistry["$key"] ]]; then
            spec="${_bar_complete_protoregistry[$key]}"
        fi
    fi
    
    # If still not found, try just the prototype
    if [[ -z "$spec" ]]; then
        if [[ -v _bar_complete_protoregistry["$proto"] ]]; then
            spec="${_bar_complete_protoregistry[$proto]}"
        else
            # No completer found - return nothing (no completions)
            return 1
        fi
    fi
    
    # Expand the spec: if it starts with "ext " keep it as "_bar_complete_ext "
    # otherwise expand with "_bar_complete_comp_"
    if [[ "$spec" == "ext "* ]]; then
        # External completer - already has the right format
        echo "_bar_complete_${spec}"
    else
        # Internal completer - expand first word with _bar_complete_comp_ prefix
        local -a spec_parts
        read -ra spec_parts <<< "$spec"
        local comp_name="${spec_parts[0]}"
        local -a comp_args=("${spec_parts[@]:1}")
        
        # Construct the expanded completer
        if [[ ${#comp_args[@]} -gt 0 ]]; then
            echo "_bar_complete_comp_${comp_name} ${comp_args[*]}"
        else
            echo "_bar_complete_comp_${comp_name}"
        fi
    fi
    
    return 0
}

# Complete parameters for a specific function or rule using dynamic protos
_bar_complete_params()
{
    local func_or_rule="$1"
    local cur="$2"
    shift 2
    local -a prev_words=("$@")
    
    # Get parameter spec for this function/rule
    local param_spec=""
    if [[ -v _bar_completion_func_params["$func_or_rule"] ]]; then
        param_spec="${_bar_completion_func_params[$func_or_rule]}"
    elif [[ -v _bar_completion_rule_params["$func_or_rule"] ]]; then
        param_spec="${_bar_completion_rule_params[$func_or_rule]}"
    fi
    
    # If no parameter spec, try generic completions
    if [[ -z "$param_spec" ]]; then
        # Default to file completion
        _bar_complete_comp_file "$cur"
        return 0
    fi
    
    # Parse the parameter spec to get protos array
    local -a protos
    mapfile -t protos < <(_bar_parse_protos "$param_spec")
    
    # Determine which proto index we're completing
    # We need to match prev_words against protos to find current position
    local proto_idx=0
    local word_idx=0
    
    # Simple matching: advance through protos as we match prev_words
    # This is a simplified version - a full implementation would handle
    # alternatives, optionals, and repeating parameters more thoroughly
    while [[ $word_idx -lt ${#prev_words[@]} ]]; do
        local proto="${protos[$proto_idx]}"
        [[ -z "$proto" ]] && break  # Reached end of protos
        
        # Check if this proto is optional (starts with [)
        local is_optional=false
        [[ "$proto" =~ ^\[ ]] && is_optional=true
        
        # Check if this proto is repeating (ends with ..)
        local is_repeating=false
        [[ "$proto" =~ \.\.$ ]] && is_repeating=true
        
        # If not repeating, advance proto_idx
        if [[ $is_repeating == false ]]; then
            proto_idx=$((proto_idx + 1))
        fi
        
        word_idx=$((word_idx + 1))
    done
    
    # Now proto_idx points to where we should complete
    local proto="${protos[$proto_idx]}"
    [[ -z "$proto" ]] && proto="${protos[0]}"  # Fallback to first proto
    
    # Extract the prototype name (remove brackets, .., etc.)
    local proto_name="$proto"
    proto_name="${proto_name#[}"
    proto_name="${proto_name%]}"
    proto_name="${proto_name%..\$}"
    
    # Check for literals (words not in <> or [])
    if [[ "$proto_name" != *'<'* && "$proto_name" != *'['* ]]; then
        # This is a literal - complete with the literal itself
        if [[ "$proto_name" == "$cur"* ]]; then
            echo "$proto_name"
        fi
        return 0
    fi
    
    # Extract prototype from <prototype>
    if [[ "$proto_name" =~ \<([^>]+)\> ]]; then
        proto_name="${BASH_REMATCH[1]}"
    fi
    
    # Handle alternatives (a|b|c)
    if [[ "$proto_name" == *'|'* ]]; then
        IFS='|' read -ra alternatives <<< "$proto_name"
        local alt
        for alt in "${alternatives[@]}"; do
            # Get completer for this alternative
            local completer
            completer=$(_bar_get_completer "$func_or_rule" "$alt")
            
            if [[ -n "$completer" ]]; then
                # Call the completer
                if [[ "$completer" == "_bar_complete_ext "* ]]; then
                    local ext_name="${completer#_bar_complete_ext }"
                    _bar_complete_ext "$ext_name" "$cur"
                else
                    $completer "$cur"
                fi
            fi
        done
        return 0
    fi
    
    # Get completer for this prototype
    local completer
    completer=$(_bar_get_completer "$func_or_rule" "$proto_name")
    
    # Skip if no completer found
    if [[ -z "$completer" ]]; then
        # Default to file completion
        _bar_complete_comp_file "$cur"
        return 0
    fi
    
    # Call the completer
    if [[ "$completer" == "_bar_complete_ext "* ]]; then
        # External completer
        local ext_name="${completer#_bar_complete_ext }"
        _bar_complete_ext "$ext_name" "$cur"
    else
        # Internal completer
        $completer "$cur"
    fi
}

# Parse a file for documented rules and functions
_bar_complete_parse_file()
{
    local public_mode=false
    local module=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --public)
                public_mode=true
                shift
                ;;
            --module)
                module="$2"
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done
    
    local file="$1"

    [[ ! -f "$file" || ! -r "$file" ]] && return
    
    # If module not specified, extract from filename
    if [[ -z "$module" ]]; then
        # For files in Bar.d/, use the basename as module name
        if [[ "$file" == *"Bar.d/"* || "$file" == *"bar.d/"* ]]; then
            module=$(basename "$file")
        fi
    fi

    local in_doc_comment=false
    local doc_params=""
    local last_doc_line=""
    
    while IFS= read -r line; do
        # Check for documented function: function name ## [params] - description
        if [[ "$line" =~ ^[[:space:]]*function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*##[[:space:]]*(.*)$ ]]; then
            local func="${BASH_REMATCH[1]}"
            local doc="${BASH_REMATCH[2]}"
            _bar_completion_functions+=("$func")
            
            # Track module for this function
            if [[ -n "$module" ]]; then
                _bar_completion_func_module[$func]="$module"
            fi
            
            # Extract parameters from documentation
            # Format: [params] - description OR just description
            if [[ "$doc" =~ ^(.+)[[:space:]]+-[[:space:]] ]]; then
                local func_params="${BASH_REMATCH[1]}"
                _bar_completion_func_params[$func]="$func_params"
            fi
            
            # Check if this is a module-specific completer (pattern: <module>_<proto>_complete)
            if [[ "$func" =~ ^([a-z][a-z0-9]*)_([a-z][a-z0-9]*)_complete$ ]]; then
                local mod="${BASH_REMATCH[1]}"
                local proto="${BASH_REMATCH[2]}"
                # Register in completion registry
                _bar_complete_protoregistry["${mod}@${proto}"]="ext $func"
                # Store in module completers list
                _bar_completion_module_completers+=("${mod}:${func}")
            fi
            
            in_doc_comment=false
            doc_params=""
            
        # Check for function preceded by doc comment
        elif [[ $in_doc_comment == true && "$line" =~ ^[[:space:]]*function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*) ]]; then
            local func="${BASH_REMATCH[1]}"
            _bar_completion_functions+=("$func")
            
            # Track module for this function
            if [[ -n "$module" ]]; then
                _bar_completion_func_module[$func]="$module"
            fi
            
            # Store parameters if we captured them
            if [[ -n "$doc_params" ]]; then
                _bar_completion_func_params[$func]="$doc_params"
            fi
            
            # Check if this is a module-specific completer (pattern: <module>_<proto>_complete)
            if [[ "$func" =~ ^([a-z][a-z0-9]*)_([a-z][a-z0-9]*)_complete$ ]]; then
                local mod="${BASH_REMATCH[1]}"
                local proto="${BASH_REMATCH[2]}"
                # Register in completion registry
                _bar_complete_protoregistry["${mod}@${proto}"]="ext $func"
                # Store in module completers list
                _bar_completion_module_completers+=("${mod}:${func}")
            fi
            
            in_doc_comment=false
            doc_params=""
            
        # In public mode, also capture undocumented functions
        elif [[ $public_mode == true && "$line" =~ ^[[:space:]]*function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*) ]]; then
            local func="${BASH_REMATCH[1]}"
            # Only add if not already added (documented ones are already in)
            local already_added=false
            for existing in "${_bar_completion_functions[@]}"; do
                if [[ "$existing" == "$func" ]]; then
                    already_added=true
                    break
                fi
            done
            if [[ $already_added == false ]]; then
                _bar_completion_functions+=("$func")
            fi
            
        # Check for documented rule: ## [params] - description followed by rule name:
        elif [[ "$line" =~ ^##[[:space:]]*(.*)$ ]]; then
            in_doc_comment=true
            last_doc_line="${BASH_REMATCH[1]}"
            # Check if this line has parameters
            if [[ "$last_doc_line" =~ ^(.+)[[:space:]]+-[[:space:]] ]]; then
                doc_params="${BASH_REMATCH[1]}"
            fi
        elif [[ $in_doc_comment == true && "$line" =~ ^[[:space:]]*rule[[:space:]]+(--[a-z_-]*[[:space:]]+)*([A-Za-z_-][A-Za-z0-9_-]*): ]]; then
            local rule="${BASH_REMATCH[2]}"
            _bar_completion_rules+=("$rule")
            
            # Track module for this rule
            if [[ -n "$module" ]]; then
                _bar_completion_rule_module[$rule]="$module"
            fi
            
            # Store parameters if we captured them
            if [[ -n "$doc_params" ]]; then
                _bar_completion_rule_params[$rule]="$doc_params"
            fi
            
            in_doc_comment=false
            doc_params=""
        elif [[ "$line" =~ ^[[:space:]]*rule[[:space:]]+(--[a-z_-]*[[:space:]]+)*([A-Za-z_-][A-Za-z0-9_-]*): ]]; then
            # In public mode, also capture undocumented rules
            if [[ $public_mode == true ]]; then
                local rule="${BASH_REMATCH[2]}"
                # Only add if not already added (documented ones are already in)
                local already_added=false
                for existing in "${_bar_completion_rules[@]}"; do
                    if [[ "$existing" == "$rule" ]]; then
                        already_added=true
                        break
                    fi
                done
                if [[ $already_added == false ]]; then
                    _bar_completion_rules+=("$rule")
                    # Track module for undocumented rules too
                    if [[ -n "$module" ]]; then
                        _bar_completion_rule_module[$rule]="$module"
                    fi
                fi
            fi
            in_doc_comment=false
            doc_params=""
        elif [[ "$line" =~ ^[[:space:]]*rule[[:space:]] ]]; then
            in_doc_comment=false
            doc_params=""
        fi
    done < "$file"
}

# Scan for rule files and parse them
_bar_scan_files()
{
    local cmd="${1:-bar}"
    
    # Clear existing data
    _bar_completion_rules=()
    _bar_completion_functions=()
    _bar_completion_rulefiles=()
    
    # Determine which files to look for
    local default_barfs=()
    if [[ "$cmd" == *please* ]]; then
        default_barfs=("Pleasef" "pleasef" ".Pleasef" ".pleasef" "$HOME/.Pleasef")
    else
        default_barfs=("Barf" "barf" ".Barf" ".barf")
    fi
    
    # Find the main rulefile
    local barf
    for barf in "${default_barfs[@]}"; do
        if [[ -f "$barf" && -r "$barf" ]]; then
            _bar_completion_rulefiles+=("$barf")
            _bar_complete_parse_file --public "$barf"
            break
        fi
    done
    
    # Add Bar.d modules if directory exists
    local bar_d_dirs=()
    if [[ "$cmd" == *please* ]]; then
        bar_d_dirs=("$HOME/.config/please")
    else
        bar_d_dirs=("Bar.d" "bar.d" ".Bar.d" ".bar.d")
    fi
    
    for bar_d in "${bar_d_dirs[@]}"; do
        if [[ -d "$bar_d" ]]; then
            for module in "$bar_d"/*; do
                [[ -f "$module" && -r "$module" ]] || continue
                _bar_complete_parse_file "$module"
            done
            break
        fi
    done
}

# Get completions
_bar_get_completions()
{
    local prefix="$1"
    
    _bar_complete_dbg "Getting completions for prefix: '$prefix'"

    local completions=()

    # Get all rules
    _bar_complete_dbg "Checking rules..."
    for rule in "${_bar_completion_rules[@]}"; do
        if [[ "$rule" == "$prefix"* ]]; then
            _bar_complete_dbg "  Adding rule: $rule"
            completions+=("$rule")
        fi
    done

    # Get all functions
    _bar_complete_dbg "Checking functions..."
    for func in "${_bar_completion_functions[@]}"; do
        if [[ "$func" == "$prefix"* ]]; then
            _bar_complete_dbg "  Adding function: $func"
            completions+=("$func")
        fi
    done

    # Add rulefile names
    _bar_complete_dbg "Checking rulefiles..."
    for file in "${_bar_completion_rulefiles[@]}"; do
        if [[ "$file" == "$prefix"* ]]; then
            _bar_complete_dbg "  Adding rulefile: $file"
            completions+=("$file")
        fi
    done

    # Remove duplicates and sort
    if [[ ${#completions[@]} -gt 0 ]]; then
        _bar_complete_dbg "Total completions found: ${#completions[@]}"
        printf '%s\n' "${completions[@]}" | sort -u
    else
        _bar_complete_dbg "No completions found"
    fi
}

# Main completion function
_bar_complete()
{
    local cur cword
    local -a protos  # Dynamic array of prototype specs
    local proto_idx=0
    
    _bar_complete_dbg "=== Bar completion triggered ==="
    
    # Initialize completion variables (works without bash-completion package)
    if type _init_completion &>/dev/null; then
        _init_completion || return
    else
        # Manual initialization
        cur="${COMP_WORDS[COMP_CWORD]}"
        cword=$COMP_CWORD
    fi
    
    _bar_complete_dbg "Command line: ${COMP_WORDS[*]}"
    _bar_complete_dbg "Current word index: $cword"
    _bar_complete_dbg "Current word: '$cur'"
    
    # Determine the command (bar, please, or a path like ./bar)
    local cmd="${COMP_WORDS[0]}"
    
    # For ./bar or similar, check if it's a bar executable
    if [[ "$cmd" == ./* || "$cmd" == ../* || "$cmd" == *"/bar" ]]; then
        # It's a path to bar
        if [[ ! -x "$cmd" ]]; then
            _bar_complete_dbg "Command not executable: $cmd"
            return
        fi
    fi
    
    # Initialize completion registry if not done yet
    if [[ ${#_bar_complete_protoregistry[@]} -eq 0 ]]; then
        _bar_complete_dbg "Initializing completion registry..."
        _bar_init_completion_registry
    fi
    
    # Scan for files
    _bar_complete_dbg "Scanning for files with command: $cmd"
    _bar_scan_files "$cmd"
    
    # Build initial protos array based on bar invocation syntax:
    # bar [rulefile] [--bare] [rule [arguments..]]
    # All are optional, so completion collects from all
    # Note: Everything in [] or <> is a prototype
    protos=("[rulefile]" "[--bare]" "[rule [arguments..]]")
    
    # Process previous words to determine current position
    local word_idx=1
    
    while [[ $word_idx -lt $cword ]]; do
        local word="${COMP_WORDS[$word_idx]}"
        _bar_complete_dbg "Processing word[$word_idx]: '$word' at proto_idx=$proto_idx"
        
        # If we've run out of protos, stay at last known position
        if [[ $proto_idx -ge ${#protos[@]} ]]; then
            _bar_complete_dbg "Beyond protos array, staying at last position"
            word_idx=$((word_idx + 1))
            continue
        fi
        
        # Try to match the word against current proto
        local matched=false
        local proto="${protos[$proto_idx]}"
        
        # Extract prototype name from proto spec (remove brackets)
        local proto_name="$proto"
        proto_name="${proto_name#[}"
        proto_name="${proto_name%]}"
        
        _bar_complete_dbg "  Trying to match '$word' against proto '$proto_name'"
        
        # Check for nested prototypes like "[rule [arguments..]]"
        # For now, extract just the first part
        if [[ "$proto_name" =~ ^([a-zA-Z_-]+)[[:space:]] ]]; then
            local first_part="${BASH_REMATCH[1]}"
            _bar_complete_dbg "  Nested proto detected, first part: $first_part"
        fi
        
        # Check if this matches a literal (check in registry if it has _bar_complete_comp_literal)
        if [[ -v _bar_complete_protoregistry["$proto_name"] ]]; then
            local completer="${_bar_complete_protoregistry[$proto_name]}"
            if [[ "$completer" == "_bar_complete_comp_literal "* ]]; then
                # This is a literal prototype - check for exact match
                local literal="${completer#_bar_complete_comp_literal }"
                if [[ "$literal" == "$word" ]]; then
                    matched=true
                    _bar_complete_dbg "  Matched literal prototype: $proto_name"
                    proto_idx=$((proto_idx + 1))
                fi
            fi
        fi
        
        # If not matched yet, check for special prototype types
        if [[ $matched == false ]]; then
            if [[ "$proto_name" =~ ^rule[[:space:]] ]] || [[ "$proto_name" == "rule" ]]; then
                # This proto expects a rule - check if word is a known rule/function
                local is_rule=false
                for rule in "${_bar_completion_rules[@]}"; do
                    if [[ "$rule" == "$word" ]]; then
                        is_rule=true
                        break
                    fi
                done
                if [[ $is_rule == false ]]; then
                    for func in "${_bar_completion_functions[@]}"; do
                        if [[ "$func" == "$word" ]]; then
                            is_rule=true
                            break
                        fi
                    done
                fi
                
                if [[ $is_rule == true ]]; then
                    _bar_complete_dbg "  Matched rule/function: $word"
                    
                    # Get parameter spec for this rule/function
                    local param_spec=""
                    if [[ -v _bar_completion_func_params["$word"] ]]; then
                        param_spec="${_bar_completion_func_params[$word]}"
                    elif [[ -v _bar_completion_rule_params["$word"] ]]; then
                        param_spec="${_bar_completion_rule_params[$word]}"
                    fi
                    
                    if [[ -n "$param_spec" ]]; then
                        # Replace remaining protos with the rule's parameter spec
                        mapfile -t protos < <(_bar_parse_protos "$param_spec")
                        proto_idx=0
                    else
                        # No param spec - check if current proto has nested [arguments..]
                        if [[ "$proto_name" =~ \[arguments\.\.?\] ]]; then
                            # Promote to [arguments..]
                            protos=("[arguments..]")
                            proto_idx=0
                        else
                            # Clear protos (any arguments accepted)
                            protos=()
                            proto_idx=0
                        fi
                    fi
                    matched=true
                fi
            elif [[ "$proto_name" == "rulefile" ]]; then
                # Check if this word is a file
                if [[ -f "$word" ]]; then
                    _bar_complete_dbg "  Matched rulefile: $word"
                    matched=true
                    proto_idx=$((proto_idx + 1))
                    # Action: parse this specific rulefile to discover its rules (with --public)
                    _bar_complete_parse_file --public "$word"
                fi
            fi
        fi
        
        # If didn't match and proto is optional, skip it and try next
        if [[ $matched == false && "$proto" == "["* ]]; then
            _bar_complete_dbg "  Didn't match, skipping optional proto: $proto"
            proto_idx=$((proto_idx + 1))
            continue  # Don't increment word_idx, try same word against next proto
        elif [[ $matched == false ]]; then
            # Required proto didn't match or unknown - move on
            _bar_complete_dbg "  Didn't match required proto, advancing anyway"
            proto_idx=$((proto_idx + 1))
        fi
        
        word_idx=$((word_idx + 1))
    done
    
    # Now generate completions based on current proto_idx
    # Collect completions from current proto and all following optional protos
    # until we hit a non-optional proto
    
    _bar_complete_dbg "Generating completions starting at proto_idx=$proto_idx"
    
    local -a all_completions=()
    local check_idx=$proto_idx
    
    while [[ $check_idx -lt ${#protos[@]} ]]; do
        local proto="${protos[$check_idx]}"
        
        # If empty or we've exhausted protos, stop
        [[ -z "$proto" ]] && break
        
        # Check if this proto is optional
        local is_optional=false
        [[ "$proto" =~ ^\[ ]] && is_optional=true
        
        _bar_complete_dbg "  Checking proto[$check_idx]: '$proto' (optional=$is_optional)"
        
        # Extract prototype name
        local proto_name="$proto"
        proto_name="${proto_name#[}"
        proto_name="${proto_name%]}"
        
        # Handle nested prototypes - extract first part for now
        if [[ "$proto_name" =~ ^([a-zA-Z_-]+)[[:space:]] ]]; then
            proto_name="${BASH_REMATCH[1]}"
            _bar_complete_dbg "  Nested proto, using first part: $proto_name"
        fi
        
        # Remove trailing .. if present
        proto_name="${proto_name%..\$}"
        proto_name="${proto_name%..}"
        
        # Get completer for this prototype from registry
        local completer
        completer=$(_bar_get_completer "" "$proto_name")
        
        if [[ -n "$completer" ]]; then
            _bar_complete_dbg "  Found completer for '$proto_name': $completer"
            
            # Call the completer based on its type
            if [[ "$completer" == "_bar_complete_ext "* ]]; then
                local ext_name="${completer#_bar_complete_ext }"
                while IFS= read -r comp; do
                    all_completions+=("$comp")
                done < <(_bar_complete_ext "$ext_name" "$cur")
            elif [[ "$completer" == "_bar_complete_comp_literal "* ]]; then
                # Literal completer - extract the literal and complete it
                local literal="${completer#_bar_complete_comp_literal }"
                if [[ "$literal" == "$cur"* ]]; then
                    all_completions+=("$literal")
                fi
            else
                # Split completer into function and arguments, then call
                # e.g., "_bar_complete_comp_file rulefile" -> function=_bar_complete_comp_file, args=rulefile
                local -a completer_parts
                read -ra completer_parts <<< "$completer"
                local comp_func="${completer_parts[0]}"
                local -a comp_args=("${completer_parts[@]:1}")
                
                while IFS= read -r comp; do
                    all_completions+=("$comp")
                done < <("$comp_func" "$cur" "${comp_args[@]}")
            fi
        else
            # No completer found, use file completion as fallback
            _bar_complete_dbg "  No completer found for '$proto_name', using file completion"
            while IFS= read -r comp; do
                all_completions+=("$comp")
            done < <(_bar_complete_comp_file "$cur")
        fi
        
        # If this proto is not optional, stop collecting
        if [[ $is_optional == false ]]; then
            break
        fi
        
        check_idx=$((check_idx + 1))
    done
    
    # Return the collected completions
    if [[ ${#all_completions[@]} -gt 0 ]]; then
        mapfile -t COMPREPLY < <(printf '%s\n' "${all_completions[@]}" | sort -u)
    fi
    
    return 0
}

# Register completion for bar and please
complete -F _bar_complete bar
complete -F _bar_complete please

# Also register for ./bar pattern (when bar is in current directory)
# This won't work perfectly for all cases, but handles the common ./bar case
if [[ -x ./bar ]]; then
    complete -F _bar_complete ./bar
fi
