#!/bin/bash
# Bash completion script for bar, please and ./bar
#
# Installation:
#   Link this file to ~/.bash_completion.d/bar_complete or source it in your .bashrc
#   Or run: bar init_install (which will create the symlink automatically)
#
# Usage:
#   After installation, bash completion will work for:
#   - bar <TAB>       - completes rulefiles, rules, and functions
#   - please <TAB>    - completes rulefiles, rules, and functions
#   - ./bar <TAB>     - completes rulefiles, rules, and functions

_bar_complete()
{
    local cur prev words cword
    
    # Initialize completion variables (works without bash-completion package)
    if type _init_completion &>/dev/null; then
        _init_completion || return
    else
        # Manual initialization
        cur="${COMP_WORDS[COMP_CWORD]}"
        prev="${COMP_WORDS[COMP_CWORD-1]}"
        words=("${COMP_WORDS[@]}")
        cword=$COMP_CWORD
    fi

    # Determine the command (bar, please, or a path like ./bar)
    local cmd="${words[0]}"
    
    # For ./bar or similar, check if it's a bar executable
    if [[ "$cmd" == ./* || "$cmd" == ../* || "$cmd" == *"/bar" ]]; then
        # It's a path to bar
        if [[ ! -x "$cmd" ]]; then
            return
        fi
    fi
    
    # Find potential rulefiles in current directory
    # These are files with 'function' or 'rule' or shebang with bar/please
    local rulefiles=()
    local file
    for file in *; do
        [[ -f "$file" && -r "$file" ]] || continue
        if head -n1 "$file" 2>/dev/null | grep -q '^#!.*\(bar\|please\)'; then
            rulefiles+=("$file")
        elif grep -qE '^[[:space:]]*(function|rule)' "$file" 2>/dev/null; then
            rulefiles+=("$file")
        fi
    done
    
    # Extract rules and functions from rulefiles and Bar.d modules
    local rules_and_functions=()
    
    # Parse default Barf/Pleasef files if they exist
    local barfs=("Barf" "barf" ".Barf" ".barf")
    if [[ "$cmd" == *please* ]]; then
        barfs=("Pleasef" "pleasef" ".Pleasef" ".pleasef" "$HOME/.Pleasef")
    fi
    
    for barf in "${barfs[@]}"; do
        if [[ -f "$barf" && -r "$barf" ]]; then
            # Extract rule names: look for "rule <name>:"
            while IFS= read -r line; do
                if [[ "$line" =~ ^[[:space:]]*rule[[:space:]]+([A-Za-z_][A-Za-z0-9_-]*): ]]; then
                    rules_and_functions+=("${BASH_REMATCH[1]}")
                elif [[ "$line" =~ ^[[:space:]]*function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*) ]]; then
                    rules_and_functions+=("${BASH_REMATCH[1]}")
                fi
            done < "$barf"
            break
        fi
    done
    
    # Parse Bar.d modules if directory exists
    local bar_d_dirs=("Bar.d" "bar.d" ".Bar.d" ".bar.d")
    for bar_d in "${bar_d_dirs[@]}"; do
        if [[ -d "$bar_d" ]]; then
            for module in "$bar_d"/*; do
                [[ -f "$module" && -r "$module" ]] || continue
                while IFS= read -r line; do
                    if [[ "$line" =~ ^[[:space:]]*rule[[:space:]]+([A-Za-z_][A-Za-z0-9_-]*): ]]; then
                        rules_and_functions+=("${BASH_REMATCH[1]}")
                    elif [[ "$line" =~ ^[[:space:]]*function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*) ]]; then
                        rules_and_functions+=("${BASH_REMATCH[1]}")
                    fi
                done < "$module"
            done
            break
        fi
    done
    
    # Combine all completions
    local completions=()
    for item in "${rulefiles[@]}" "${rules_and_functions[@]}"; do
        if [[ "$item" == "$cur"* ]]; then
            completions+=("$item")
        fi
    done
    
    # Remove duplicates and sort
    if [[ ${#completions[@]} -gt 0 ]]; then
        mapfile -t COMPREPLY < <(printf '%s\n' "${completions[@]}" | sort -u)
    fi
    
    return 0
}

# Register completion for bar and please
complete -F _bar_complete bar
complete -F _bar_complete please

# Also register for ./bar pattern (when bar is in current directory)
# This won't work perfectly for all cases, but handles the common ./bar case
if [[ -x ./bar ]]; then
    complete -F _bar_complete ./bar
fi
