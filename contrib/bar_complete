#!/bin/bash
# Bash completion script for bar, please and ./bar
#
# This script parses documented rules and functions (those with ## doc comments)
# and provides intelligent completion with caching for performance.
#
# Installation:
#   Link this file to ~/.bash_completion/bar_complete or source it in your .bashrc
#   Or run: bar init_install (which will create the symlink automatically)
#
# Usage:
#   After installation, bash completion will work for:
#   - bar <TAB>       - completes rulefiles, rules, and functions
#   - please <TAB>    - completes rulefiles, rules, and functions
#   - ./bar <TAB>     - completes rulefiles, rules, and functions

# Debug logging function - set BAR_COMPLETE_DEBUG=1 to enable
_bar_complete_dbg()
{
    [[ -n "$BAR_COMPLETE_DEBUG" ]] && echo "$*" >&2
}

# Cache arrays for completion data
# _bar_completion_barf_files: indexed array storing "mtime:filename" for all discovered rule files
declare -ga _bar_completion_barf_files=()
# _bar_completion_barf_path: associative array "basepath" -> "0 1 3" (indices into barf_files)
declare -gA _bar_completion_barf_path=()
# _bar_completion_barf_files_freelist: string of free indices for reuse
declare -g  _bar_completion_barf_files_freelist=""

# _bar_completion_rules: indexed array storing "fileindex:rulename" for all discovered rules
declare -ga _bar_completion_rules=()
# _bar_completion_rules_path: associative array "basepath" -> "0 1 3" (indices into rules)
declare -gA _bar_completion_rules_path=()
# _bar_completion_rules_freelist: string of free indices for reuse
declare -g  _bar_completion_rules_freelist=""

# _bar_completion_functions: indexed array storing "fileindex:funcname" for all discovered functions
declare -ga _bar_completion_functions=()
# _bar_completion_functions_path: associative array "basepath" -> "0 1 3" (indices into functions)
declare -gA _bar_completion_functions_path=()
# _bar_completion_functions_freelist: string of free indices for reuse
declare -g  _bar_completion_functions_freelist=""

# _bar_completion_dir_mtime: associative array "path" -> mtime for tracking directory changes
# The goal: when in a basedir where we start bar, we can find recursively if any dir/file
# has changed by mtime, if so then only the changed files need to be reparsed.
declare -gA _bar_completion_dir_mtime=()

# Parameter completion data structures
# _bar_completion_func_params: associative array "funcname" -> "param_list"
# param_list is space-separated list of parameters like: "[--opt] <file> [output]"
declare -gA _bar_completion_func_params=()

# _bar_completion_rule_params: associative array "rulename" -> "param_list"
declare -gA _bar_completion_rule_params=()

# _bar_completion_registry: associative array "prototype" -> "completer_function [predicates]"
# Maps parameter prototypes to their completion functions
# Examples: registry["file"]="_bar_complete_file"
#           registry["cargo@toolchain"]="_bar_extcomplete cargo_toolchain_complete"
declare -gA _bar_completion_registry=()

# _bar_completion_extcomplete_cache: associative array "completer_name" -> "cached_results"
# Cache for external completion results
declare -gA _bar_completion_extcomplete_cache=()

# _bar_completion_module_completers: indexed array storing module-specific completers
# Format: "module:completer_name"
declare -ga _bar_completion_module_completers=()

# Helper: Get modification time of a file or directory with high resolution
_bar_get_mtime()
{
    # Use format %y to get timestamp with nanoseconds, then extract the time portion
    local mtime_str
    mtime_str=$(stat --format='%y' "$1" 2>/dev/null) || { echo 0; return; }
    # Extract timestamp: "2025-10-13 16:49:38.517259371 +0000" -> "2025-10-13 16:49:38.517259371"
    # Convert to epochseconds.nanoseconds for comparison
    local datetime="${mtime_str% *}"
    # Use date to convert to epoch with nanoseconds preserved
    local epoch
    epoch=$(date -d "$datetime" +%s.%N 2>/dev/null) || echo 0
    echo "$epoch"
}

# Helper: Find free slot in an array or append
_bar_alloc_slot()
{
    local freelist_var="$1"
    local array_var="$2"
    
    # Get the freelist value
    local freelist="${!freelist_var}"
    
    if [[ -n "$freelist" ]]; then
        local slot
        read -r slot freelist <<< "$freelist"
        # Update the freelist variable
        printf -v "$freelist_var" '%s' "$freelist"
        echo "$slot"
    else
        # Get array size using nameref
        local -n arr="$array_var"
        echo "${#arr[@]}"
    fi
}

# Helper: Free a slot in an array
_bar_free_slot()
{
    local freelist_var="$1"
    local array_var="$2"
    local slot="$3"

    # Add slot to freelist
    local freelist="${!freelist_var}"
    printf -v "$freelist_var" '%s' "$slot $freelist"

    # Clear the array entry
    local -n arr="$array_var"
    arr[slot]=""
}

# Generic completion functions

# Apply predicate filters to completions
_bar_apply_predicates()
{
    local -a predicates=("$@")
    local item
    
    # Read items from stdin
    while IFS= read -r item; do
        local pass=true
        local pred
        for pred in "${predicates[@]}"; do
            # Call predicate function to test item
            if ! "_bar_complete_predicate_${pred}" "$item" 2>/dev/null; then
                pass=false
                break
            fi
        done
        [[ $pass == true ]] && echo "$item"
    done
}

# Predicate: file exists
_bar_complete_predicate_existing()
{
    [[ -e "$1" ]]
}

# Predicate: file does not exist
_bar_complete_predicate_nonexisting()
{
    [[ ! -e "$1" ]]
}

# Predicate: is in local directory
_bar_complete_predicate_local()
{
    [[ "$1" != */* ]]
}

# Predicate: is a rulefile
# Checks for:
# 1. Conventional names: Barf*, Pleasef*, example*
# 2. Bar/please shebangs: #!/.*bar or #!/.*please
# 3. Bash scripts with rules: #!/.*bash + contains rule/function
# 4. Documented files: Contains ## + rule/function
_bar_complete_predicate_rulefile()
{
    local file="$1"
    [[ -f "$file" && -r "$file" ]] || return 1
    
    # Check for conventional rulefile names
    if [[ "$file" =~ ^(Barf|Pleasef|example)(\.[a-z]+)?$ ]] || \
       [[ "$file" =~ ^[Bb]ar[Ff]\..*$ ]] || \
       [[ "$file" =~ ^[Pp]leasef\..*$ ]]; then
        return 0
    fi
    
    # Check shebang and content
    local shebang
    shebang=$(head -n1 "$file" 2>/dev/null)
    
    # Bar/please shebang
    if [[ "$shebang" =~ ^#!.*(bar|please) ]]; then
        return 0
    fi
    
    # Bash shebang + contains rules/functions
    if [[ "$shebang" =~ ^#!/.*bash ]]; then
        if grep -qE '^[[:space:]]*(function|rule)[[:space:]]' "$file" 2>/dev/null; then
            return 0
        fi
    fi
    
    # Documented file with rules/functions
    if grep -qE '^[[:space:]]*##' "$file" 2>/dev/null && \
       grep -qE '^[[:space:]]*(function|rule)' "$file" 2>/dev/null; then
        return 0
    fi
    
    return 1
}

# Complete file paths
_bar_complete_file()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    # Use bash's built-in file completion
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -f -- "$cur" | _bar_apply_predicates "${predicates[@]}"
    else
        compgen -f -- "$cur"
    fi
}

# Complete directory paths
_bar_complete_directory()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -d -- "$cur" | _bar_apply_predicates "${predicates[@]}"
    else
        compgen -d -- "$cur"
    fi
}

# Complete any path (file or directory)
_bar_complete_path()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -f -- "$cur" | _bar_apply_predicates "${predicates[@]}"
    else
        compgen -f -- "$cur"
    fi
}

# Complete with existing rule names
_bar_complete_rule()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    local curdir="$PWD"
    
    # Get all rules from cache
    local -a rules=()
    for idx in ${_bar_completion_rules_path[$curdir]:-}; do
        local entry="${_bar_completion_rules[$idx]}"
        local rule="${entry#*:}"
        if [[ "$rule" == "$cur"* ]]; then
            rules+=("$rule")
        fi
    done
    
    # Apply predicates if specified
    if [[ ${#predicates[@]} -gt 0 ]]; then
        printf '%s\n' "${rules[@]}" | _bar_apply_predicates "${predicates[@]}"
    else
        printf '%s\n' "${rules[@]}"
    fi
}

# Complete with command/function names
_bar_complete_command()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    
    # Complete with functions and commands in PATH
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -c -- "$cur" | _bar_apply_predicates "${predicates[@]}"
    else
        compgen -c -- "$cur"
    fi
}

# Complete with command, function, or rule names
_bar_complete_command_or_rule()
{
    local cur="$1"
    shift
    local -a predicates=("$@")
    local curdir="$PWD"
    
    # Collect all candidates
    local -a candidates=()
    
    # Get rules from cache
    for idx in ${_bar_completion_rules_path[$curdir]:-}; do
        local entry="${_bar_completion_rules[$idx]}"
        local rule="${entry#*:}"
        if [[ "$rule" == "$cur"* ]]; then
            candidates+=("$rule")
        fi
    done
    
    # Get functions from cache
    for idx in ${_bar_completion_functions_path[$curdir]:-}; do
        local entry="${_bar_completion_functions[$idx]}"
        local func="${entry#*:}"
        if [[ "$func" == "$cur"* ]]; then
            candidates+=("$func")
        fi
    done
    
    # Get commands from PATH
    while IFS= read -r cmd; do
        candidates+=("$cmd")
    done < <(compgen -c -- "$cur")
    
    # Remove duplicates and apply predicates
    if [[ ${#predicates[@]} -gt 0 ]]; then
        printf '%s\n' "${candidates[@]}" | sort -u | _bar_apply_predicates "${predicates[@]}"
    else
        printf '%s\n' "${candidates[@]}" | sort -u
    fi
}

# External completer - calls bar --bare <completer_name> to get completions
_bar_extcomplete()
{
    local completer_name="$1"
    local cur="$2"
    
    # Check cache first
    if [[ -v _bar_completion_extcomplete_cache["$completer_name"] ]]; then
        local cached="${_bar_completion_extcomplete_cache[$completer_name]}"
        # Filter cached results by current prefix
        local result
        for result in $cached; do
            if [[ "$result" == "$cur"* ]]; then
                echo "$result"
            fi
        done
        return 0
    fi
    
    # Call bar --bare to get completions
    local results
    if results=$(bar --bare "$completer_name" 2>/dev/null); then
        # Cache the results
        _bar_completion_extcomplete_cache[$completer_name]="$results"
        # Filter and return
        local result
        for result in $results; do
            if [[ "$result" == "$cur"* ]]; then
                echo "$result"
            fi
        done
    fi
}

# Initialize default completion registry
_bar_init_completion_registry()
{
    # Generic completers
    _bar_completion_registry[file]="_bar_complete_file"
    _bar_completion_registry[directory]="_bar_complete_directory"
    _bar_completion_registry[path]="_bar_complete_path"
    _bar_completion_registry[rule]="_bar_complete_rule"
    _bar_completion_registry[command]="_bar_complete_command"
    _bar_completion_registry[command_or_rule]="_bar_complete_command_or_rule"
    
    # Add module-specific completers (populated during file parsing)
}

# Parse parameter spec and extract individual parameters
# Input: "[--opt] <file> [output..]"
# Output: array of parameters (without decorators)
_bar_parse_params()
{
    local param_spec="$1"
    local -a params=()
    
    # Simple tokenization - split on spaces, handling brackets and angle brackets
    # This is a simplified parser; a full implementation would need better parsing
    local token
    for token in $param_spec; do
        # Remove decorators and extract identifier
        local clean_token="$token"
        # Remove leading/trailing brackets, angles, dots
        clean_token="${clean_token#[}"
        clean_token="${clean_token#<}"
        clean_token="${clean_token%]}"
        clean_token="${clean_token%>}"
        clean_token="${clean_token%..}"
        
        # Skip empty tokens and special markers
        [[ -z "$clean_token" || "$clean_token" == "-" || "$clean_token" == "--" ]] && continue
        
        # Store the token
        params+=("$clean_token")
    done
    
    printf '%s\n' "${params[@]}"
}

# Get completer for a prototype
# Looks up: func@proto, then proto
_bar_get_completer()
{
    local func_or_rule="$1"
    local proto="$2"
    
    # Try hierarchical lookup: func@proto first
    local key="${func_or_rule}@${proto}"
    if [[ -v _bar_completion_registry["$key"] ]]; then
        echo "${_bar_completion_registry[$key]}"
        return 0
    fi
    
    # Try just the prototype
    if [[ -v _bar_completion_registry["$proto"] ]]; then
        echo "${_bar_completion_registry[$proto]}"
        return 0
    fi
    
    # No completer found - return nothing (no completions)
    return 1
}

# Complete parameters for a specific function or rule
_bar_complete_params()
{
    local func_or_rule="$1"
    local cur="$2"
    shift 2
    local -a prev_words=("$@")
    
    # Get parameter spec for this function/rule
    local param_spec=""
    if [[ -v _bar_completion_func_params["$func_or_rule"] ]]; then
        param_spec="${_bar_completion_func_params[$func_or_rule]}"
    elif [[ -v _bar_completion_rule_params["$func_or_rule"] ]]; then
        param_spec="${_bar_completion_rule_params[$func_or_rule]}"
    fi
    
    # If no parameter spec, try generic completions
    if [[ -z "$param_spec" ]]; then
        # Default to file completion
        _bar_complete_file "$cur"
        return 0
    fi
    
    # Parse the parameter spec to get list of parameter prototypes
    local -a params
    mapfile -t params < <(_bar_parse_params "$param_spec")
    
    # Simple completion: offer completions for each parameter type
    # A more sophisticated implementation would track which parameters have been used
    local proto
    for proto in "${params[@]}"; do
        # Get completer for this prototype
        local completer
        completer=$(_bar_get_completer "$func_or_rule" "$proto")
        
        # Skip if no completer found
        [[ -z "$completer" ]] && continue
        
        # Call the completer
        if [[ "$completer" == "_bar_extcomplete "* ]]; then
            # External completer
            local ext_name="${completer#_bar_extcomplete }"
            _bar_extcomplete "$ext_name" "$cur"
        else
            # Internal completer
            $completer "$cur"
        fi
    done
}

# Parse a file for documented rules and functions
_bar_parse_file()
{
    local file="$1"
    local file_idx="$2"  # Index in _bar_completion_barf_files
    local curdir="$PWD"

    [[ ! -f "$file" || ! -r "$file" ]] && return

    local in_doc_comment=false

    # First, clear old entries for this file
    # Find and free all rules from this file
    local indices="${_bar_completion_rules_path[$curdir]:-}"
    local new_rule_indices=""
    for idx in $indices; do
        local entry="${_bar_completion_rules[$idx]}"
        local entry_file_idx="${entry%%:*}"
        if [[ "$entry_file_idx" != "$file_idx" ]]; then
            new_rule_indices="$new_rule_indices $idx"
        else
            _bar_free_slot "_bar_completion_rules_freelist" "_bar_completion_rules" "$idx"
        fi
    done
    _bar_completion_rules_path[$curdir]="${new_rule_indices# }"

    # Find and free all functions from this file
    indices="${_bar_completion_functions_path[$curdir]:-}"
    local new_func_indices=""
    for idx in $indices; do
        local entry="${_bar_completion_functions[$idx]}"
        local entry_file_idx="${entry%%:*}"
        if [[ "$entry_file_idx" != "$file_idx" ]]; then
            new_func_indices="$new_func_indices $idx"
        else
            _bar_free_slot "_bar_completion_functions_freelist" "_bar_completion_functions" "$idx"
        fi
    done
    _bar_completion_functions_path[$curdir]="${new_func_indices# }"

    # Parse file line by line looking for documented entities
    local doc_params=""
    local last_doc_line=""
    while IFS= read -r line; do
        # Check for documented function: function name ## [params] - description
        if [[ "$line" =~ ^[[:space:]]*function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*##[[:space:]]*(.*)$ ]]; then
            local func="${BASH_REMATCH[1]}"
            local doc="${BASH_REMATCH[2]}"
            local slot
            slot=$(_bar_alloc_slot "_bar_completion_functions_freelist" "_bar_completion_functions")
            _bar_completion_functions[slot]="$file_idx:$func"
            _bar_completion_functions_path[$curdir]="${_bar_completion_functions_path[$curdir]:-} $slot"
            
            # Extract parameters from documentation
            # Format: [params] - description OR just description
            if [[ "$doc" =~ ^(.+)[[:space:]]+-[[:space:]] ]]; then
                local func_params="${BASH_REMATCH[1]}"
                _bar_completion_func_params[$func]="$func_params"
            fi
            
            # Check if this is a module-specific completer (pattern: <module>_<proto>_complete)
            if [[ "$func" =~ ^([a-z][a-z0-9]*)_([a-z][a-z0-9]*)_complete$ ]]; then
                local module="${BASH_REMATCH[1]}"
                local proto="${BASH_REMATCH[2]}"
                # Register in completion registry
                _bar_completion_registry["${module}@${proto}"]="_bar_extcomplete $func"
                # Store in module completers list
                _bar_completion_module_completers+=("${module}:${func}")
            fi
            
            in_doc_comment=false
            doc_params=""
            
        # Check for function preceded by doc comment
        elif [[ $in_doc_comment == true && "$line" =~ ^[[:space:]]*function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*) ]]; then
            local func="${BASH_REMATCH[1]}"
            local slot
            slot=$(_bar_alloc_slot "_bar_completion_functions_freelist" "_bar_completion_functions")
            _bar_completion_functions[slot]="$file_idx:$func"
            _bar_completion_functions_path[$curdir]="${_bar_completion_functions_path[$curdir]:-} $slot"
            
            # Store parameters if we captured them
            if [[ -n "$doc_params" ]]; then
                _bar_completion_func_params[$func]="$doc_params"
            fi
            
            # Check if this is a module-specific completer (pattern: <module>_<proto>_complete)
            if [[ "$func" =~ ^([a-z][a-z0-9]*)_([a-z][a-z0-9]*)_complete$ ]]; then
                local module="${BASH_REMATCH[1]}"
                local proto="${BASH_REMATCH[2]}"
                # Register in completion registry
                _bar_completion_registry["${module}@${proto}"]="_bar_extcomplete $func"
                # Store in module completers list
                _bar_completion_module_completers+=("${module}:${func}")
            fi
            
            in_doc_comment=false
            doc_params=""
            
        # Check for documented rule: ## [params] - description followed by rule name:
        elif [[ "$line" =~ ^##[[:space:]]*(.*)$ ]]; then
            in_doc_comment=true
            last_doc_line="${BASH_REMATCH[1]}"
            # Check if this line has parameters
            if [[ "$last_doc_line" =~ ^(.+)[[:space:]]+-[[:space:]] ]]; then
                doc_params="${BASH_REMATCH[1]}"
            fi
        elif [[ $in_doc_comment == true && "$line" =~ ^[[:space:]]*rule[[:space:]]+(--[a-z_-]*[[:space:]]+)*([A-Za-z_-][A-Za-z0-9_-]*): ]]; then
            local rule="${BASH_REMATCH[2]}"
            local slot
            slot=$(_bar_alloc_slot "_bar_completion_rules_freelist" "_bar_completion_rules")
            _bar_completion_rules[slot]="$file_idx:$rule"
            _bar_completion_rules_path[$curdir]="${_bar_completion_rules_path[$curdir]:-} $slot"
            
            # Store parameters if we captured them
            if [[ -n "$doc_params" ]]; then
                _bar_completion_rule_params[$rule]="$doc_params"
            fi
            
            in_doc_comment=false
            doc_params=""
        elif [[ "$line" =~ ^[[:space:]]*rule[[:space:]] ]]; then
            in_doc_comment=false
            doc_params=""
        fi
    done < "$file"

    # Trim leading spaces
    _bar_completion_rules_path[$curdir]="${_bar_completion_rules_path[$curdir]# }"
    _bar_completion_functions_path[$curdir]="${_bar_completion_functions_path[$curdir]# }"
}

# Update cache for current directory
_bar_update_cache()
{
    local curdir="$PWD"
    local cmd="${1:-bar}"

    # Determine which files to look for
    local default_barfs=()
    if [[ "$cmd" == *please* ]]; then
        default_barfs=("Pleasef" "pleasef" ".Pleasef" ".pleasef" "$HOME/.Pleasef")
    else
        default_barfs=("Barf" "barf" ".Barf" ".barf")
    fi

    # Check if directory mtime has changed (need to rescan for new files)
    local dir_mtime
    dir_mtime=$(_bar_get_mtime "$curdir")
    local cached_dir_mtime="${_bar_completion_dir_mtime[$curdir]:-0}"

    local need_rescan=false
    if [[ "$dir_mtime" != "$cached_dir_mtime" ]]; then
        need_rescan=true
        _bar_completion_dir_mtime["$curdir"]="$dir_mtime"
    fi

    # Build list of current barf files and check their mtimes
    local current_files=()
    local file_indices=()

    # Find ALL potential rule files in current directory using predicate-based filtering
    if [[ $need_rescan == true ]]; then
        _bar_complete_dbg "Scanning directory for rule files using predicates..."
        
        # Use _bar_complete_file with predicates to find all rulefiles
        # Get all files in current directory
        local -a all_files
        mapfile -t all_files < <(compgen -f)
        
        # Filter using predicates: local AND rulefile
        for file in "${all_files[@]}"; do
            if _bar_complete_predicate_local "$file"; then
                if _bar_complete_predicate_rulefile "$file"; then
                    _bar_complete_dbg "  Found rulefile: $file"
                    current_files+=("$file")
                fi
            fi
        done
    fi

    # Ensure all default Barf/Pleasef names are included if they exist
    for barf in "${default_barfs[@]}"; do
        if [[ -f "$barf" && -r "$barf" ]]; then
            # Check if not already in list
            local already_added=false
            for cf in "${current_files[@]}"; do
                if [[ "$cf" == "$barf" ]]; then
                    already_added=true
                    break
                fi
            done
            if [[ $already_added == false ]]; then
                _bar_complete_dbg "  Adding default file: $barf"
                current_files+=("$barf")
            fi
        fi
    done

    # Add Bar.d modules if directory exists
    local bar_d_dirs=()
    if [[ "$cmd" == *please* ]]; then
        bar_d_dirs=("$HOME/.config/please")
    else
        bar_d_dirs=("Bar.d" "bar.d" ".Bar.d" ".bar.d")
    fi
    
    for bar_d in "${bar_d_dirs[@]}"; do
        if [[ -d "$bar_d" ]]; then
            for module in "$bar_d"/*; do
                [[ -f "$module" && -r "$module" ]] || continue
                current_files+=("$module")
            done
            break
        fi
    done

    # Process each file and update cache if needed
    for file in "${current_files[@]}"; do
        local file_mtime
        file_mtime=$(_bar_get_mtime "$file")

        # Check if we have this file cached
        local cached=false
        local slot
        for idx in ${_bar_completion_barf_path[$curdir]:-}; do
            local entry="${_bar_completion_barf_files[$idx]}"
            local cached_mtime="${entry%%:*}"
            local cached_file="${entry#*:}"
            if [[ "$cached_file" == "$file" ]]; then
                cached=true
                slot=$idx
                if [[ "$cached_mtime" != "$file_mtime" ]]; then
                    # File changed, reparse
                    _bar_parse_file "$file" "$slot"
                    _bar_completion_barf_files[idx]="$file_mtime:$file"
                fi
                break
            fi
        done

        if [[ $cached == false ]]; then
            # New file, add to cache
            slot=$(_bar_alloc_slot "_bar_completion_barf_files_freelist" "_bar_completion_barf_files")
            _bar_completion_barf_files[slot]="$file_mtime:$file"
            _bar_completion_barf_path[$curdir]="${_bar_completion_barf_path[$curdir]:-} $slot"
            _bar_parse_file "$file" "$slot"
            file_indices+=("$slot")
        else
            file_indices+=("$slot")
        fi
    done

    # Clean up removed files from cache
    if [[ -n "${_bar_completion_barf_path[$curdir]:-}" ]]; then
        local new_indices=""
        for idx in ${_bar_completion_barf_path[$curdir]}; do
            local found=false
            for check_idx in "${file_indices[@]}"; do
                if [[ "$idx" == "$check_idx" ]]; then
                    found=true
                    break
                fi
            done
            if [[ $found == false ]]; then
                # File removed, free the slot
                _bar_free_slot "_bar_completion_barf_files_freelist" "_bar_completion_barf_files" "$idx"
            else
                new_indices="$new_indices $idx"
            fi
        done
        _bar_completion_barf_path[$curdir]="${new_indices# }"
    fi
}

# Get completions from cache
_bar_get_completions()
{
    local curdir="$PWD"
    local prefix="$1"
    
    _bar_complete_dbg "Getting completions for prefix: '$prefix'"
    _bar_complete_dbg "Current directory: $curdir"

    local completions=()

    # Get all rules from cached files
    _bar_complete_dbg "Checking rules..."
    for idx in ${_bar_completion_rules_path[$curdir]:-}; do
        local entry="${_bar_completion_rules[$idx]}"
        local rule="${entry#*:}"
        if [[ "$rule" == "$prefix"* ]]; then
            _bar_complete_dbg "  Adding rule: $rule"
            completions+=("$rule")
        fi
    done

    # Get all functions from cached files
    _bar_complete_dbg "Checking functions..."
    for idx in ${_bar_completion_functions_path[$curdir]:-}; do
        local entry="${_bar_completion_functions[$idx]}"
        local func="${entry#*:}"
        if [[ "$func" == "$prefix"* ]]; then
            _bar_complete_dbg "  Adding function: $func"
            completions+=("$func")
        fi
    done

    # Add rulefile names (from current directory)
    _bar_complete_dbg "Checking rulefiles..."
    _bar_complete_dbg "Barf path indices: ${_bar_completion_barf_path[$curdir]:-none}"
    for idx in ${_bar_completion_barf_path[$curdir]:-}; do
        local entry="${_bar_completion_barf_files[$idx]}"
        local file="${entry#*:}"
        _bar_complete_dbg "  Checking file: $file"
        # Only include files from current directory (not Bar.d modules)
        if [[ "$file" != */* && "$file" == "$prefix"* ]]; then
            _bar_complete_dbg "  Adding rulefile: $file"
            completions+=("$file")
        else
            _bar_complete_dbg "  Skipping file: $file (path filter or prefix mismatch)"
        fi
    done

    # Remove duplicates and sort
    if [[ ${#completions[@]} -gt 0 ]]; then
        _bar_complete_dbg "Total completions found: ${#completions[@]}"
        printf '%s\n' "${completions[@]}" | sort -u
    else
        _bar_complete_dbg "No completions found"
    fi
}

# Main completion function
_bar_complete()
{
    local cur words cword
    
    _bar_complete_dbg "=== Bar completion triggered ==="
    
    # Initialize completion variables (works without bash-completion package)
    if type _init_completion &>/dev/null; then
        _init_completion || return
    else
        # Manual initialization
        cur="${COMP_WORDS[COMP_CWORD]}"
        words=("${COMP_WORDS[@]}")
        cword=$COMP_CWORD
    fi
    
    _bar_complete_dbg "Command line: ${words[*]}"
    _bar_complete_dbg "Current word index: $cword"
    _bar_complete_dbg "Current word: '$cur'"
    
    # Determine the command (bar, please, or a path like ./bar)
    local cmd="${words[0]}"
    
    # For ./bar or similar, check if it's a bar executable
    if [[ "$cmd" == ./* || "$cmd" == ../* || "$cmd" == *"/bar" ]]; then
        # It's a path to bar
        if [[ ! -x "$cmd" ]]; then
            _bar_complete_dbg "Command not executable: $cmd"
            return
        fi
    fi
    
    # Initialize completion registry if not done yet
    if [[ ${#_bar_completion_registry[@]} -eq 0 ]]; then
        _bar_complete_dbg "Initializing completion registry..."
        _bar_init_completion_registry
    fi
    
    # Update cache for current directory
    _bar_complete_dbg "Updating cache for command: $cmd"
    _bar_update_cache "$cmd"
    
    # Determine completion context
    # words[0] = bar/please/./bar
    # words[1] = might be rulefile or --bare or rule/function name
    # words[2+] = might be arguments to the rule/function
    
    local completing_what=""
    local func_or_rule=""
    
    # Analyze command line structure
    if [[ $cword -eq 1 ]]; then
        # First argument - could be rulefile, --bare, or rule/function
        completing_what="rule_or_file"
    elif [[ "${words[1]}" == "--bare" ]]; then
        if [[ $cword -eq 2 ]]; then
            # Second argument after --bare - rule/function name
            completing_what="rule_or_function"
        else
            # Arguments to the rule/function
            func_or_rule="${words[2]}"
            completing_what="params"
        fi
    elif [[ -f "${words[1]}" ]]; then
        # First arg is a file (rulefile)
        if [[ $cword -eq 2 ]]; then
            # Second argument - rule/function name
            completing_what="rule_or_function"
        else
            # Arguments to the rule/function
            func_or_rule="${words[2]}"
            completing_what="params"
        fi
    else
        # First arg is likely a rule/function name
        if [[ $cword -eq 1 ]]; then
            completing_what="rule_or_function"
        else
            func_or_rule="${words[1]}"
            completing_what="params"
        fi
    fi
    
    # Generate completions based on context
    _bar_complete_dbg "Completion context: $completing_what"
    case "$completing_what" in
        rule_or_file)
            # Complete with files and rules/functions
            _bar_complete_dbg "Completing with rulefiles, rules, and functions"
            mapfile -t COMPREPLY < <(_bar_get_completions "$cur")
            ;;
        rule_or_function)
            # Complete with rules and functions only (not files)
            _bar_complete_dbg "Completing with rules and functions only"
            local completions=()
            local curdir="$PWD"
            
            # Get rules
            for idx in ${_bar_completion_rules_path[$curdir]:-}; do
                local entry="${_bar_completion_rules[$idx]}"
                local rule="${entry#*:}"
                if [[ "$rule" == "$cur"* ]]; then
                    completions+=("$rule")
                fi
            done
            
            # Get functions
            for idx in ${_bar_completion_functions_path[$curdir]:-}; do
                local entry="${_bar_completion_functions[$idx]}"
                local func="${entry#*:}"
                if [[ "$func" == "$cur"* ]]; then
                    completions+=("$func")
                fi
            done
            
            if [[ ${#completions[@]} -gt 0 ]]; then
                mapfile -t COMPREPLY < <(printf '%s\n' "${completions[@]}" | sort -u)
            fi
            ;;
        params)
            # Complete parameters for the specific function/rule
            if [[ -n "$func_or_rule" ]]; then
                # Build array of previous words (for context-aware completion)
                local -a prev_words=()
                local i
                for ((i=3; i<cword; i++)); do
                    prev_words+=("${words[i]}")
                done
                
                mapfile -t COMPREPLY < <(_bar_complete_params "$func_or_rule" "$cur" "${prev_words[@]}")
            else
                # Fallback to file completion
                mapfile -t COMPREPLY < <(compgen -f -- "$cur")
            fi
            ;;
        *)
            # Default to file completion
            mapfile -t COMPREPLY < <(compgen -f -- "$cur")
            ;;
    esac
    
    return 0
}

# Register completion for bar and please
complete -F _bar_complete bar
complete -F _bar_complete please

# Also register for ./bar pattern (when bar is in current directory)
# This won't work perfectly for all cases, but handles the common ./bar case
if [[ -x ./bar ]]; then
    complete -F _bar_complete ./bar
fi
