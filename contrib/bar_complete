#!/bin/bash
# Bash completion script for bar, please and ./bar
#
# This script parses documented rules and functions (those with ## doc comments)
# and provides intelligent completion.
#
# Installation:
#   Link this file to ~/.bash_completion/bar_complete or source it in your .bashrc
#   Or run: bar init_install (which will create the symlink automatically)
#
# Usage:
#   After installation, bash completion will work for:
#   - bar <TAB>       - completes rulefiles, rules, and functions
#   - please <TAB>    - completes rulefiles, rules, and functions
#   - ./bar <TAB>     - completes rulefiles, rules, and functions
#
# API Surface:
#   This file defines several public functions and variables that are used by
#   the completion system and may be referenced by tests:
#
#   PUBLIC (single underscore or for bash completion registration):
#     _bar_complete              - main completion entry point (registered with bash)
#     _bar_parse_protos          - parse parameter spec into prototypes
#     _bar_expand_group_alternatives - expand proto alternatives
#     _bar_extract_literal_punct - extract literal punctuation from proto
#
#   SEMI-PUBLIC (double underscore, but used by tests/external modules):
#     __bar_rules                - array of discovered rule names
#     __bar_functions            - array of discovered function names
#     __bar_func_params          - map of function -> parameter spec
#     __bar_rule_params          - map of rule -> parameter spec
#     __bar_func_module          - map of function -> module name
#     __bar_protoregistry        - map of prototype -> completer spec
#     __bar_parse_file           - parse a file for rules/functions
#     __bar_scan_files           - scan for and parse rulefiles
#     __bar_init_completion_registry - initialize builtin completers
#     __bar_get_completer        - get completer for a prototype
#     __bar_comp_*               - various completion functions
#
#   INTERNAL (double underscore, implementation details):
#     All other __bar_* functions and variables are internal implementation
#     details and should not be relied upon by external code. They may change
#     without notice.

# Debug logging function - set BAR_COMPLETE_DEBUG=1 to enable
__bar_dbg()
{
    [[ -n "$BAR_COMPLETE_DEBUG" ]] && echo "$*" >&2
}

# Data structures for completion
# __bar_rules: array storing rule names
declare -ga __bar_rules=()

# __bar_functions: array storing function names
declare -ga __bar_functions=()

# __bar_rulefiles: array storing rulefile names (internal to __bar_scan_files)
# declare -ga __bar_rulefiles=()

# Parameter completion data structures
# __bar_func_params: associative array "funcname" -> "param_list"
# param_list is space-separated list of parameters like: "[--opt] <file> [output]"
declare -gA __bar_func_params=()

# __bar_rule_params: associative array "rulename" -> "param_list"
declare -gA __bar_rule_params=()

# __bar_func_module: associative array "funcname" -> "module"
# Tracks which module a function came from for module-specific completers
declare -gA __bar_func_module=()

# __bar_rule_module: associative array "rulename" -> "module"
# Tracks which module a rule came from for module-specific completers
declare -gA __bar_rule_module=()

# __bar_protoregistry: associative array "prototype" -> "completer_function [predicates]"
# Maps parameter prototypes to their completion functions
# Examples: registry["file"]="file"
#           registry["cargo@toolchain"]="extcomp cargo"
declare -gA __bar_protoregistry=()

# __bar_actions: associative array "prototype" -> "action_function"
# Maps prototypes to actions that should be executed when that prototype is matched
# Examples: actions["rulefile"]="_bar_action_parse_rulefile"
# Currently unused - reserved for future action-based completion extensions
# declare -gA __bar_actions=()

# __bar_cache: array caching the completions for the current word
declare -ga __bar_cache=()

# __bar_cache_signature: signature of the current completion context
declare -g __bar_cache_signature=""

# __bar_cache_prefix: prefix used when populating the cache
declare -g __bar_cache_prefix=""

# __bar_extcomplete_cache: associative array "completer_name" -> "cached_results"
# Cache for external completion results
declare -gA __bar_extcomplete_cache=()

# __bar_module_completers: indexed array storing module-specific completers
# Format: "module:completer_name"
# Currently populated but unused - reserved for future completer introspection
# declare -ga __bar_module_completers=()

# Command used to invoke completion (bar, please, ./bar, etc.)
declare -g __bar_invocation=""

# State for dynamic external command completion passthrough
declare -g __bar_extcomp_command=""
declare -gi __bar_extcomp_command_index=-1

# Generic completion functions

# Apply predicate filters to completions
__bar_apply_predicates()
{
    local -a predicates=("$@")
    local item

    # Read items from stdin
    while IFS= read -r item; do
        local pass=true
        local pred
        for pred in "${predicates[@]}"; do
            # Call predicate function to test item
            if ! "__bar_pred_${pred}" "$item" 2>/dev/null; then
                pass=false
                break
            fi
        done
        [[ $pass == true ]] && echo "$item"
    done
}

# Predicate: file exists
__bar_pred_existing()
{
    [[ -e "$1" ]]
}

# Predicate: file does not exist
__bar_pred_nonexisting()
{
    [[ ! -e "$1" ]]
}

# Predicate: is in local directory
__bar_pred_local()
{
    [[ "$1" != */* ]]
}

# Predicate: is a rulefile
# Checks if file is readable and has a shebang AND contains rule or function statements
__bar_pred_rulefile()
{
    if [[ -f "$1" && -r "$1" ]]; then
        # Check for shebang in first line AND rule/function statements
        local first_line
        read -r first_line < "$1" 2>/dev/null
        if [[ "$first_line" != '#!/'* ]]; then
            return 1
        fi
        grep -qE '^(rule|function)[[:space:]]' "$1" 2>/dev/null
    else
        return 1
    fi
}

# Complete file paths
__bar_comp_file()
{
    local cur="$1"
    shift
    local -a predicates=("$@")

    # Use bash's built-in file completion
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -f -- "$cur" | __bar_apply_predicates "${predicates[@]}"
    else
        compgen -f -- "$cur"
    fi
}

# Complete directory paths
__bar_comp_directory()
{
    local cur="$1"
    shift
    local -a predicates=("$@")

    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -d -- "$cur" | __bar_apply_predicates "${predicates[@]}"
    else
        compgen -d -- "$cur"
    fi
}

# Complete any path (file or directory)
__bar_comp_path()
{
    local cur="$1"
    shift
    local -a predicates=("$@")

    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -f -- "$cur" | __bar_apply_predicates "${predicates[@]}"
    else
        compgen -f -- "$cur"
    fi
}

# Complete with existing rule names
__bar_comp_rule()
{
    local cur="$1"
    shift
    local -a predicates=("$@")

    # Get all rules
    local -a rules=()
    for rule in "${__bar_rules[@]}"; do
        if [[ "$rule" == "$cur"* ]]; then
            rules+=("$rule")
        fi
    done

    # Apply predicates if specified
    if [[ ${#predicates[@]} -gt 0 ]]; then
        if [[ ${#rules[@]} -gt 0 ]]; then
            printf '%s\n' "${rules[@]}" | __bar_apply_predicates "${predicates[@]}"
        fi
    else
        if [[ ${#rules[@]} -gt 0 ]]; then
            printf '%s\n' "${rules[@]}"
        fi
    fi
}

# Complete with rule or function names (no system commands)
__bar_comp_rule_or_function()
{
    local cur="$1"
    shift
    local -a predicates=("$@")

    # Collect all candidates
    local -a candidates=()

    # Get rules
    for rule in "${__bar_rules[@]}"; do
        if [[ "$rule" == "$cur"* ]]; then
            candidates+=("$rule")
        fi
    done

    # Get functions
    for func in "${__bar_functions[@]}"; do
        if [[ "$func" == "$cur"* ]]; then
            candidates+=("$func")
        fi
    done

    # Apply predicates if specified
    if [[ ${#predicates[@]} -gt 0 ]]; then
        if [[ ${#candidates[@]} -gt 0 ]]; then
            printf '%s\n' "${candidates[@]}" | __bar_apply_predicates "${predicates[@]}"
        fi
    else
        if [[ ${#candidates[@]} -gt 0 ]]; then
            printf '%s\n' "${candidates[@]}"
        fi
    fi
}

# Complete with command/function names
__bar_comp_command()
{
    local cur="$1"
    shift
    local -a predicates=("$@")

    # Complete with functions and commands in PATH
    if [[ ${#predicates[@]} -gt 0 ]]; then
        compgen -c -- "$cur" | __bar_apply_predicates "${predicates[@]}"
    else
        compgen -c -- "$cur"
    fi
}

# Complete with command, function, or rule names
__bar_comp_command_or_rule()
{
    local cur="$1"
    shift
    local -a predicates=("$@")

    # Collect all candidates
    local -a candidates=()

    # Get rules
    for rule in "${__bar_rules[@]}"; do
        if [[ "$rule" == "$cur"* ]]; then
            candidates+=("$rule")
        fi
    done

    # Get functions
    for func in "${__bar_functions[@]}"; do
        if [[ "$func" == "$cur"* ]]; then
            candidates+=("$func")
        fi
    done

    # Get commands from PATH
    while IFS= read -r cmd; do
        candidates+=("$cmd")
    done < <(compgen -c -- "$cur")

    # Remove duplicates and apply predicates
    if [[ ${#predicates[@]} -gt 0 ]]; then
        if [[ ${#candidates[@]} -gt 0 ]]; then
            printf '%s\n' "${candidates[@]}" | sort -u | __bar_apply_predicates "${predicates[@]}"
        fi
    else
        if [[ ${#candidates[@]} -gt 0 ]]; then
            printf '%s\n' "${candidates[@]}" | sort -u
        fi
    fi
}

# Complete with a literal keyword
# This completer is bound to a prototype and completes to that literal
__bar_comp_literal()
{
    local cur="$1"
    local literal="$2"  # The literal keyword to complete

    # If the literal starts with the current prefix, offer it as completion
    if [[ "$literal" == "$cur"* ]]; then
        echo "$literal"
    fi
}

# Complete help topics, rules, functions, and variables via help_indexer
__bar_comp_help()
{
    local cur="${1:-}"

    if ! declare -p __bar_help_index &>/dev/null; then
        declare -ga __bar_help_index=()
    fi
    if ! declare -p __bar_help_rindex &>/dev/null; then
        declare -gA __bar_help_rindex=()
    fi

    if (( ${#__bar_help_index[@]} == 0 )); then
        local -a index_lines=()
        local zero_base="${0##*/}"

        if [[ "$zero_base" == "bar" || "$zero_base" == "please" ]]; then
            if ! mapfile -t index_lines < <("$0" help_indexer 2>/dev/null); then
                index_lines=()
            fi
        fi

        if (( ${#index_lines[@]} == 0 )); then
            if [[ "$zero_base" == "bar" || "$zero_base" == "please" ]]; then
                if mapfile -t index_lines < <("$0" --bare help_indexer 2>/dev/null); then
                    :
                fi
            fi
        fi

        if (( ${#index_lines[@]} == 0 )); then
            local fallback="${__bar_invocation:-}"

            if [[ -n "$fallback" ]]; then
                if [[ "$fallback" == ./* || "$fallback" == ../* ]]; then
                    [[ -x "$fallback" ]] || fallback=""
                elif [[ "$fallback" == */bar ]]; then
                    [[ -x "$fallback" ]] || fallback=""
                elif ! command -v "$fallback" >/dev/null 2>&1; then
                    fallback=""
                fi
            fi

            if [[ -z "$fallback" ]]; then
                if command -v bar >/dev/null 2>&1; then
                    fallback="bar"
                elif command -v please >/dev/null 2>&1; then
                    fallback="please"
                elif [[ -x ./bar ]]; then
                    fallback="./bar"
                fi
            fi

            if [[ -n "$fallback" ]]; then
                if ! mapfile -t index_lines < <("$fallback" --bare help_indexer 2>/dev/null); then
                    mapfile -t index_lines < <("$fallback" help_indexer 2>/dev/null)
                fi
            fi
        fi

        if (( ${#index_lines[@]} > 0 )); then
            __bar_help_index=("${index_lines[@]}")
            local idx
            for idx in "${!__bar_help_index[@]}"; do
                local entry="${__bar_help_index[$idx]}"
                [[ -z "$entry" ]] && continue
                local value="${entry#*:*:}"
                [[ -z "$value" ]] && continue
                local key="${value,,}"
                if [[ -n "$key" && ! -v __bar_help_rindex["$key"] ]]; then
                    __bar_help_rindex["$key"]="$idx"
                fi
            done
        fi
    fi

    if (( ${#__bar_help_rindex[@]} == 0 )); then
        return 0
    fi

    local lc_cur="${cur,,}"
    local -a matches=()
    local key
    for key in "${!__bar_help_rindex[@]}"; do
        if [[ -z "$lc_cur" || "$key" == "$lc_cur"* ]]; then
            local idx="${__bar_help_rindex[$key]}"
            local entry="${__bar_help_index[$idx]}"
            local value="${entry#*:*:}"
            [[ -z "$value" ]] && continue
            matches+=("$value")
        fi
    done

    if (( ${#matches[@]} > 0 )); then
        printf '%s\n' "${matches[@]}" | sort -u | while IFS= read -r item; do
            printf '%q\n' "$item"
        done
    fi
}

# External completer - calls bar --bare <completer_name> to get completions
__bar_comp_ext()
{
    local completer_name="$1"
    local cur="$2"

    # Check cache first
    if [[ -v __bar_extcomplete_cache["$completer_name"] ]]; then
        local cached="${__bar_extcomplete_cache[$completer_name]}"
        # Filter cached results by current prefix
        local result
        for result in $cached; do
            if [[ "$result" == "$cur"* ]]; then
                echo "$result"
            fi
        done
        return 0
    fi

    # Determine which bar executable to use (bar, please, ./bar, etc.)
    local bar_cmd="${__bar_invocation:-}"
    if [[ -z "$bar_cmd" ]]; then
        if command -v bar >/dev/null 2>&1; then
            bar_cmd="bar"
        elif command -v please >/dev/null 2>&1; then
            bar_cmd="please"
        elif [[ -x ./bar ]]; then
            bar_cmd="./bar"
        fi
    fi

    [[ -n "$bar_cmd" ]] || return 0

    # Call bar --bare to get completions
    local results
    if results=$("$bar_cmd" --bare "$completer_name" 2>/dev/null); then
        # Cache the results
        __bar_extcomplete_cache[$completer_name]="$results"
        # Filter and return
        local result
        for result in $results; do
            if [[ "$result" == "$cur"* ]]; then
                echo "$result"
            fi
        done
    fi
}

# External command completion - invokes external command's bash completion as black box
# Usage: __bar_comp_extcomp <command> [args...]
# Example: __bar_comp_extcomp git checkout ma
# Supports ${VARIABLE} expansion in arguments: extcomp cargo ${CARGO_TOOLCHAIN} build
__bar_comp_extcomp()
{
    local cmd="$1"
    shift
    local -a args=()
    local -a remaining_args=("$@")

    # Allow the command specification to contain preset arguments (e.g. "cargo +nightly")
    if [[ "$cmd" == *' '* ]]; then
        local -a cmd_parts=()
        read -ra cmd_parts <<< "$cmd"
        cmd="${cmd_parts[0]}"
        if (( ${#cmd_parts[@]} > 1 )); then
            args+=("${cmd_parts[@]:1}")
        fi
    fi

    # Process arguments from cmd_parts first, expanding ${VARIABLE} references
    local -a expanded_args=()
    local arg
    for arg in "${args[@]}"; do
        # Check if argument contains ${...} pattern
        if [[ "$arg" =~ \$\{[^}]+\} ]]; then
            # Use eval to expand the variable
            local expanded
            expanded=$(eval echo "$arg")
            # Only add if it's not empty (variable was set)
            if [[ -n "$expanded" ]]; then
                expanded_args+=("$expanded")
            fi
        else
            expanded_args+=("$arg")
        fi
    done

    # Now add remaining arguments passed to the function
    for arg in "${remaining_args[@]}"; do
        # Check if argument contains ${...} pattern
        if [[ "$arg" =~ \$\{[^}]+\} ]]; then
            # Use eval to expand the variable
            local expanded
            expanded=$(eval echo "$arg")
            # Only add if it's not empty (variable was set)
            if [[ -n "$expanded" ]]; then
                expanded_args+=("$expanded")
            fi
        else
            expanded_args+=("$arg")
        fi
    done

    args=("${expanded_args[@]}")

    # Get the current word to complete (last argument)
    local cur="${args[-1]:-}"

    # Source bash-completion if not already loaded
    if [[ ! $(type -t _completion_loader) == function ]]; then
        if [[ -f /usr/share/bash-completion/bash_completion ]]; then
            # shellcheck disable=SC1091
            source /usr/share/bash-completion/bash_completion 2>/dev/null || true
        elif [[ -f /etc/bash_completion ]]; then
            # shellcheck disable=SC1091
            source /etc/bash_completion 2>/dev/null || true
        fi
    fi

    # Capture any existing completion specification before attempting to load more
    local comp_spec=""
    if ! comp_spec=$(complete -p "$cmd" 2>/dev/null); then
        # Try to load completion for the command only if none exists yet
        if type -t _completion_loader &>/dev/null; then
            _completion_loader "$cmd" 2>/dev/null || true
            comp_spec=$(complete -p "$cmd" 2>/dev/null)
        fi
    fi

    if [[ -z "$comp_spec" ]]; then
        # No completion available, fall back to file completion
        compgen -f -- "$cur"
        return
    fi

    # Extract the completion function name from the spec
    # Format: complete -F <function> <command>
    local comp_func
    if [[ "$comp_spec" =~ -F[[:space:]]+([^[:space:]]+) ]]; then
        comp_func="${BASH_REMATCH[1]}"
    else
        # Not a function-based completion, fall back
        compgen -f -- "$cur"
        return
    fi

    # Check if the completion function exists
    if ! type -t "$comp_func" &>/dev/null; then
        compgen -f -- "$cur"
        return
    fi

    # Set up completion environment
    COMP_WORDS=("$cmd" "${args[@]}")
    COMP_CWORD=$((${#COMP_WORDS[@]} - 1))
    COMP_LINE="${COMP_WORDS[*]}"
    COMP_POINT=${#COMP_LINE}
    COMPREPLY=()

    # Call the completion function
    "$comp_func" 2>/dev/null || true

    # Filter results by current prefix
    if [[ -n "$cur" ]]; then
        printf '%s\n' "${COMPREPLY[@]}" | grep "^${cur}"
    else
        printf '%s\n' "${COMPREPLY[@]}"
    fi
}

__bar_extcomp_has_completion()
{
    local cmd="$1"

    # Ensure bash-completion is available so we can load specs on demand
    if [[ ! $(type -t _completion_loader) == function ]]; then
        if [[ -f /usr/share/bash-completion/bash_completion ]]; then
            # shellcheck disable=SC1091
            source /usr/share/bash-completion/bash_completion 2>/dev/null || true
        elif [[ -f /etc/bash_completion ]]; then
            # shellcheck disable=SC1091
            source /etc/bash_completion 2>/dev/null || true
        fi
    fi

    if complete -p "$cmd" >/dev/null 2>&1; then
        return 0
    fi

    if type -t _completion_loader &>/dev/null; then
        _completion_loader "$cmd" 2>/dev/null || true
    fi

    complete -p "$cmd" >/dev/null 2>&1
}

__bar_comp_extcomp_context()
{
    local cur="$1"
    local command="$2"
    local start_index="${3:-$__bar_extcomp_command_index}"

    local -a args=()

    if [[ -n "$command" && $start_index -ge 0 ]]; then
        local i
        for ((i=start_index+1; i<COMP_CWORD; i++)); do
            args+=("${COMP_WORDS[i]}")
        done
    fi

    args+=("$cur")

    __bar_comp_extcomp "$command" "${args[@]}"
}

# Initialize default completion registry
__bar_init_completion_registry()
{
    # Generic completers
    __bar_protoregistry[file]="file"
    __bar_protoregistry[directory]="directory"
    __bar_protoregistry[path]="path"
    __bar_protoregistry[rule]="rule_or_function"
    __bar_protoregistry[command]="command"
    __bar_protoregistry[command_or_rule]="command_or_rule"
    __bar_protoregistry[help]="help"

    # Rulefile completer - uses file completer with rulefile predicate
    __bar_protoregistry[rulefile]="file rulefile"

    # Literal completers - register specific literals
    __bar_protoregistry[--bare]="literal --bare"

    # Arguments completer - default file completion
    __bar_protoregistry[arguments]="file"

    # Add module-specific completers (populated during file parsing)
}

# Parse parameter spec into protos array
# Input: param_spec like "[--opt] <file> [output]"
# Output: protos array with parsed prototypes
_bar_parse_protos()
{
    local param_spec="$1"
    local -a protos=()

    # Tokenize the parameter spec
    # This is a simplified parser for the formal parameter syntax
    local in_bracket=false
    local in_angle=false
    local current_token=""
    local is_optional=false

    local i
    for ((i=0; i<${#param_spec}; i++)); do
        local char="${param_spec:$i:1}"

        case "$char" in
            '[')
                in_bracket=true
                is_optional=true
                ;;
            '<')
                in_angle=true
                current_token=""
                ;;
            ']'|'>')
                if [[ -n "$current_token" ]]; then
                    # Check for .. suffix
                    local repeating=false
                    if [[ "${param_spec:$((i+1)):2}" == ".." ]]; then
                        repeating=true
                        i=$((i+2))
                    fi

                    # Store the prototype
                    local proto_entry="$current_token"
                    [[ $is_optional == true ]] && proto_entry="[$proto_entry]"
                    [[ $repeating == true ]] && proto_entry="${proto_entry}.."
                    protos+=("$proto_entry")
                    current_token=""
                fi
                in_bracket=false
                in_angle=false
                is_optional=false
                ;;
            ' '|$'\t')
                # Space separates tokens
                if [[ -n "$current_token" && $in_bracket == false && $in_angle == false ]]; then
                    # Literal word
                    protos+=("$current_token")
                    current_token=""
                fi
                ;;
            *)
                current_token="${current_token}${char}"
                ;;
        esac
    done

    # Handle any remaining token
    if [[ -n "$current_token" ]]; then
        protos+=("$current_token")
    fi

    # Add empty terminator
    protos+=("")

    printf '%s\n' "${protos[@]}"
}

# Expand a proto spec to find alternatives at the beginning
# Input: proto spec string like "[[--verbose] foo [bar|baz]]"
# Output: List of alternatives available at start, one per line
# Format: ALTERNATIVE (just the token, caller determines if literal)
#
# Algorithm:
# - Recursively expand nested groups
# - Return all alternatives at the start
# - Continue through optional items and stop after first required item
#
# Note: This function expands ONE level of a proto spec.
# For the protos array with multiple entries, the caller needs to handle
# collecting from multiple proto entries.
_bar_expand_group_alternatives()
{
    local spec="$1"
    local collect_mode="${2:-first_required}"  # first_required or optional_only

    # Remove leading/trailing whitespace
    spec="$(echo "$spec" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
    [[ -z "$spec" ]] && return 0

    # Check if entire spec is an optional group [...]
    # Need to match brackets carefully - find the matching closing bracket
    if [[ "${spec:0:1}" == "[" ]]; then
        local depth=0
        local i
        for ((i=0; i<${#spec}; i++)); do
            case "${spec:$i:1}" in
                '[') depth=$((depth + 1)) ;;
                ']') depth=$((depth - 1)) ;;
            esac
            if [[ $depth -eq 0 ]]; then
                break
            fi
        done
        # If the closing bracket is at the end, this is a complete [] group
        if [[ $i -eq $((${#spec} - 1)) ]]; then
            local inner="${spec:1:$((i-1))}"
            # Optional group - expand inner and continue with optional_only mode
            # since anything after an optional is also considered
            _bar_expand_group_alternatives "$inner" "optional_only"
            return 0
        fi
    fi

    # Check if entire spec is a required group <...>
    if [[ "${spec:0:1}" == "<" ]]; then
        local depth=0
        local i
        for ((i=0; i<${#spec}; i++)); do
            case "${spec:$i:1}" in
                '<') depth=$((depth + 1)) ;;
                '>') depth=$((depth - 1)) ;;
            esac
            if [[ $depth -eq 0 ]]; then
                break
            fi
        done
        # If the closing angle is at the end, this is a complete <> group
        if [[ $i -eq $((${#spec} - 1)) ]]; then
            local inner="${spec:1:$((i-1))}"
            _bar_expand_group_alternatives "$inner" "first_required"
            return 0
        fi
    fi

    # Check for top-level alternatives (| outside groups)
    # Need to split by | carefully, respecting nested groups
    local has_top_level_alt=false
    local depth=0
    local i
    for ((i=0; i<${#spec}; i++)); do
        local char="${spec:$i:1}"
        case "$char" in
            '[' | '<') depth=$((depth + 1)) ;;
            ']' | '>') depth=$((depth - 1)) ;;
            '|')
                if [[ $depth -eq 0 ]]; then
                    has_top_level_alt=true
                    break
                fi
                ;;
        esac
    done

    if [[ $has_top_level_alt == true ]]; then
        # Split by top-level | and recursively expand each part
        local depth=0
        local current=""
        local i
        for ((i=0; i<${#spec}; i++)); do
            local char="${spec:$i:1}"
            case "$char" in
                '[' | '<')
                    depth=$((depth + 1))
                    current+="$char"
                    ;;
                ']' | '>')
                    depth=$((depth - 1))
                    current+="$char"
                    ;;
                '|')
                    if [[ $depth -eq 0 ]]; then
                        # Split point
                        _bar_expand_group_alternatives "$current" "$collect_mode"
                        current=""
                    else
                        current+="$char"
                    fi
                    ;;
                *)
                    current+="$char"
                    ;;
            esac
        done
        # Process last part
        if [[ -n "$current" ]]; then
            _bar_expand_group_alternatives "$current" "$collect_mode"
        fi
        return 0
    fi

    # No top-level alternatives - extract first token
    # A token is either:
    # - A group [...]  or <...>
    # - A literal/proto word

    local first_token=""
    local rest_of_spec=""
    local depth=0

    local i
    for ((i=0; i<${#spec}; i++)); do
        local char="${spec:$i:1}"
        case "$char" in
            '[' | '<')
                depth=$((depth + 1))
                first_token+="$char"
                ;;
            ']' | '>')
                depth=$((depth - 1))
                first_token+="$char"
                if [[ $depth -eq 0 ]]; then
                    # End of group - check for .. suffix
                    if [[ "${spec:$((i+1)):2}" == ".." ]]; then
                        first_token+=".."
                        i=$((i + 2))
                    fi
                    # Get the rest of the spec
                    rest_of_spec="${spec:$((i+1))}"
                    break
                fi
                ;;
            ' ' | $'\t')
                if [[ $depth -eq 0 ]]; then
                    # End of first token at top level
                    rest_of_spec="${spec:$((i+1))}"
                    break
                else
                    first_token+="$char"
                fi
                ;;
            *)
                first_token+="$char"
                ;;
        esac
    done

    # If we consumed everything, first_token is the whole spec
    if [[ $i -ge $((${#spec} - 1)) ]]; then
        first_token="$spec"
        rest_of_spec=""
    fi

    # Remove leading/trailing whitespace from tokens
    first_token="$(echo "$first_token" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
    rest_of_spec="$(echo "$rest_of_spec" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"

    # Check if first_token is optional
    local token_is_optional=false
    if [[ "$first_token" =~ ^\[.*\]$ ]]; then
        token_is_optional=true
    fi

    # If first_token is a group, recursively expand it
    if [[ "$first_token" =~ ^\[.*\]$ ]] || [[ "$first_token" =~ ^\<.*\>$ ]]; then
        _bar_expand_group_alternatives "$first_token" "$collect_mode"
    else
        # It's a literal or proto - output it
        echo "$first_token"
    fi

    # Continue with rest of spec based on mode and whether first was optional
    if [[ -n "$rest_of_spec" ]]; then
        if [[ $collect_mode == "first_required" ]]; then
            if [[ $token_is_optional == true ]]; then
                # First was optional, continue collecting (including first required)
                _bar_expand_group_alternatives "$rest_of_spec" "first_required"
            fi
            # If first was required, we stop (already output it above)
        elif [[ $collect_mode == "optional_only" ]]; then
            if [[ $token_is_optional == true ]]; then
                # Continue with optional_only mode
                _bar_expand_group_alternatives "$rest_of_spec" "optional_only"
            fi
            # If we hit a required item, stop
        fi
    fi
}

# Get completer for a prototype
# Looks up: module@proto (if module known), then func@proto, then proto
# Returns expanded completer spec (with __bar_comp_ prefix)
__bar_get_completer()
{
    local func_or_rule="$1"
    local proto="$2"
    local spec=""

    if [[ "$func_or_rule" == __extcomp::* ]]; then
        local command="${func_or_rule#__extcomp::}"
        if [[ "$proto" == "commandargs" ]]; then
            echo "__bar_comp_extcomp_context $command $__bar_extcomp_command_index"
            return 0
        fi
    fi

    # Try to get module for this func/rule
    local module=""
    if [[ -v __bar_func_module["$func_or_rule"] ]]; then
        module="${__bar_func_module[$func_or_rule]}"
    elif [[ -v __bar_rule_module["$func_or_rule"] ]]; then
        module="${__bar_rule_module[$func_or_rule]}"
    fi

    # Try module@proto lookup first if we know the module
    if [[ -n "$module" ]]; then
        local key="${module}@${proto}"
        if [[ -v __bar_protoregistry["$key"] ]]; then
            spec="${__bar_protoregistry[$key]}"
        fi
    fi

    # If not found, try hierarchical lookup: func@proto
    if [[ -z "$spec" && -n "$func_or_rule" ]]; then
        local key="${func_or_rule}@${proto}"
        if [[ -v __bar_protoregistry["$key"] ]]; then
            spec="${__bar_protoregistry[$key]}"
        fi
    fi

    # If still not found, try just the prototype
    if [[ -z "$spec" ]]; then
        if [[ -v __bar_protoregistry["$proto"] ]]; then
            spec="${__bar_protoregistry[$proto]}"
        else
            # No completer found - return nothing (no completions)
            return 1
        fi
    fi

    # Expand the spec: 
    # - "ext funcname" → "__bar_comp_ext funcname"
    # - "extcomp command" → "__bar_comp_extcomp command"
    # - otherwise expand with "__bar_comp_"
    if [[ "$spec" == "ext "* ]]; then
        # External completer - convert "ext funcname" to "__bar_comp_ext funcname"
        local ext_func="${spec#ext }"
        echo "__bar_comp_ext $ext_func"
    elif [[ "$spec" == "extcomp "* ]]; then
        # External command completion - convert "extcomp command" to "__bar_comp_extcomp command"
        local ext_cmd="${spec#extcomp }"
        echo "__bar_comp_extcomp $ext_cmd"
    else
        # Internal completer - expand first word with __bar_comp_ prefix
        local -a spec_parts
        read -ra spec_parts <<< "$spec"
        local comp_name="${spec_parts[0]}"
        local -a comp_args=("${spec_parts[@]:1}")

        # Construct the expanded completer
        if [[ ${#comp_args[@]} -gt 0 ]]; then
            echo "__bar_comp_${comp_name} ${comp_args[*]}"
        else
            echo "__bar_comp_${comp_name}"
        fi
    fi

    return 0
}

# Complete parameters for a specific function or rule using dynamic protos
__bar_params()
{
    local func_or_rule="$1"
    local cur="$2"
    shift 2
    local -a prev_words=("$@")

    # Get parameter spec for this function/rule
    local param_spec=""
    if [[ -v __bar_rule_params["$func_or_rule"] ]]; then
        param_spec="${__bar_rule_params[$func_or_rule]}"
    elif [[ -v __bar_func_params["$func_or_rule"] ]]; then
        param_spec="${__bar_func_params[$func_or_rule]}"
    fi

    # If no parameter spec, try generic completions
    if [[ -z "$param_spec" ]]; then
        # Default to file completion
        __bar_comp_file "$cur"
        return 0
    fi

    # Parse the parameter spec to get protos array
    local -a protos
    mapfile -t protos < <(_bar_parse_protos "$param_spec")

    # Determine which proto index we're completing
    # We need to match prev_words against protos to find current position
    local proto_idx=0
    local word_idx=0

    # Simple matching: advance through protos as we match prev_words
    # This is a simplified version - a full implementation would handle
    # alternatives, optionals, and repeating parameters more thoroughly
    while [[ $word_idx -lt ${#prev_words[@]} ]]; do
        local proto="${protos[$proto_idx]}"
        [[ -z "$proto" ]] && break  # Reached end of protos

        # Check if this proto is optional (starts with [)
        local is_optional=false
        [[ "$proto" =~ ^\[ ]] && is_optional=true

        # Check if this proto is repeating (ends with ..)
        local is_repeating=false
        [[ "$proto" =~ \.\.$ ]] && is_repeating=true

        # If not repeating, advance proto_idx
        if [[ $is_repeating == false ]]; then
            proto_idx=$((proto_idx + 1))
        fi

        word_idx=$((word_idx + 1))
    done

    # Now proto_idx points to where we should complete
    local proto="${protos[$proto_idx]}"
    [[ -z "$proto" ]] && proto="${protos[0]}"  # Fallback to first proto

    # Extract the prototype name (remove brackets, .., etc.)
    local proto_name="$proto"
    proto_name="${proto_name#[}"
    proto_name="${proto_name%]}"
    proto_name="${proto_name%..\$}"

    # Check for literals (words not in <> or [])
    if [[ "$proto_name" != *'<'* && "$proto_name" != *'['* ]]; then
        # This is a literal - complete with the literal itself
        if [[ "$proto_name" == "$cur"* ]]; then
            echo "$proto_name"
        fi
        return 0
    fi

    # Extract prototype from <prototype>
    if [[ "$proto_name" =~ \<([^>]+)\> ]]; then
        proto_name="${BASH_REMATCH[1]}"
    fi

    # Handle literal punctuation (e.g., +toolchain, rule:)
    local -a punct_parts
    mapfile -t punct_parts < <(_bar_extract_literal_punct "$proto_name")
    local proto_clean="${punct_parts[0]}"
    local literal_prefix="${punct_parts[1]}"
    local literal_suffix="${punct_parts[2]}"

    # If we have literal prefix, handle it
    if [[ -n "$literal_prefix" ]]; then
        # Check if current input already has the literal prefix
        if [[ "$cur" == "$literal_prefix"* ]]; then
            # User has typed the literal, strip it for prototype completion
            cur="${cur#"$literal_prefix"}"
            proto_name="$proto_clean"
        else
            # User hasn't typed the literal yet or is typing it
            # We need to call the completer and prefix all results with the literal
            proto_name="$proto_clean"

            # Get completer for this prototype
            local completer
            completer=$(__bar_get_completer "$func_or_rule" "$proto_name")

            if [[ -z "$completer" ]]; then
                # No completer found, just offer the literal if it matches
                if [[ "$literal_prefix" == "$cur"* ]]; then
                    echo "$literal_prefix"
                fi
                return 0
            fi

            # Call the completer with empty prefix to get all options
            local -a proto_completions=()
            if [[ "$completer" == "__bar_comp_ext "* ]]; then
                local ext_name="${completer#__bar_comp_ext }"
                mapfile -t proto_completions < <(__bar_comp_ext "$ext_name" "")
            elif [[ "$completer" == "__bar_comp_extcomp "* ]]; then
                local ext_cmd="${completer#__bar_comp_extcomp }"
                mapfile -t proto_completions < <(__bar_comp_extcomp "$ext_cmd" "")
            else
                mapfile -t proto_completions < <($completer "")
            fi

            # Prefix each completion with the literal and filter by current input
            for proto_comp in "${proto_completions[@]}"; do
                local full_comp="${literal_prefix}${proto_comp}"
                if [[ "$full_comp" == "$cur"* ]]; then
                    echo "$full_comp"
                fi
            done
            return 0
        fi
    else
        proto_name="$proto_clean"
    fi

    # Handle alternatives (a|b|c)
    if [[ "$proto_name" == *'|'* ]]; then
        IFS='|' read -ra alternatives <<< "$proto_name"
        local alt
        for alt in "${alternatives[@]}"; do
            # Get completer for this alternative
            local completer
            completer=$(__bar_get_completer "$func_or_rule" "$alt")

            if [[ -n "$completer" ]]; then
                # Call the completer
                if [[ "$completer" == "__bar_comp_ext "* ]]; then
                    local ext_name="${completer#__bar_comp_ext }"
                    __bar_comp_ext "$ext_name" "$cur"
                elif [[ "$completer" == "__bar_comp_extcomp "* ]]; then
                    local ext_cmd="${completer#__bar_comp_extcomp }"
                    __bar_comp_extcomp "$ext_cmd" "$cur"
                else
                    $completer "$cur"
                fi
            fi
        done
        return 0
    fi

    # Get completer for this prototype
    local completer
    completer=$(__bar_get_completer "$func_or_rule" "$proto_name")

    # Skip if no completer found
    if [[ -z "$completer" ]]; then
        # Default to file completion
        __bar_comp_file "$cur"
        return 0
    fi

    # Call the completer
    if [[ "$completer" == "__bar_comp_ext "* ]]; then
        # External completer
        local ext_name="${completer#__bar_comp_ext }"
        __bar_comp_ext "$ext_name" "$cur"
    elif [[ "$completer" == "__bar_comp_extcomp "* ]]; then
        # External command completion
        local ext_cmd="${completer#__bar_comp_extcomp }"
        __bar_comp_extcomp "$ext_cmd" "$cur"
    else
        # Internal completer
        $completer "$cur"
    fi
}

# Helper function to extract literal punctuation from prototype
# Input: proto like "+toolchain" or "rule:"
# Returns: proto_clean literal_prefix literal_suffix (one per line)
_bar_extract_literal_punct()
{
    local proto="$1"
    local literal_prefix=""
    local literal_suffix=""

    # Extract leading literal punctuation (not -- or - followed by letter)
    # Punctuation is anything that's not alphanumeric, underscore, or hyphen
    while [[ -n "$proto" ]]; do
        # Check if starts with -- or -[a-zA-Z] (these are NOT literals)
        if [[ "$proto" =~ ^-- ]] || [[ "$proto" =~ ^-[a-zA-Z] ]]; then
            break
        fi

        # Check if starts with punctuation
        if [[ "$proto" =~ ^([^a-zA-Z0-9_-])(.*)$ ]]; then
            literal_prefix="${literal_prefix}${BASH_REMATCH[1]}"
            proto="${BASH_REMATCH[2]}"
        else
            break
        fi
    done

    # Extract trailing literal punctuation (not ..)
    while [[ -n "$proto" ]]; do
        # Check if ends with .. (this is NOT literal, it's for repetition)
        if [[ "$proto" =~ \.\.$ ]]; then
            break
        fi

        # Check if ends with punctuation
        if [[ "$proto" =~ ^(.*)([^a-zA-Z0-9_])$ ]]; then
            proto="${BASH_REMATCH[1]}"
            literal_suffix="${BASH_REMATCH[2]}${literal_suffix}"
        else
            break
        fi
    done

    # Return values via echo (one per line)
    echo "$proto"
    echo "$literal_prefix"
    echo "$literal_suffix"
}

# Apply literal prefix/suffix to a completion item when needed
__bar_apply_literals()
{
    local item="$1"
    local literal_prefix="$2"
    local literal_suffix="$3"

    if [[ -n "$literal_prefix" && "$item" != "$literal_prefix"* ]]; then
        item="${literal_prefix}${item}"
    fi

    if [[ -n "$literal_suffix" && "$item" != *"$literal_suffix" ]]; then
        item="${item}${literal_suffix}"
    fi

    printf '%s\n' "$item"
}

# Sort completions so flagged options stay visible first, then cleanly deduplicate.
__bar_finalize_completions()
{
    local -a items=("$@")
    local -A seen=()
    local -a flags=()
    local -a nonflags=()
    local item

    for item in "${items[@]}"; do
        [[ -n "$item" ]] || continue
        if [[ -v seen["$item"] ]]; then
            continue
        fi
        seen["$item"]=1
        if [[ "$item" == -* ]]; then
            flags+=("$item")
        else
            nonflags+=("$item")
        fi
    done

    if [[ ${#flags[@]} -gt 0 ]]; then
        mapfile -t flags < <(printf '%s\n' "${flags[@]}" | sort)
    fi
    if [[ ${#nonflags[@]} -gt 0 ]]; then
        mapfile -t nonflags < <(printf '%s\n' "${nonflags[@]}" | sort)
    fi

    printf '%s\n' "${flags[@]}" "${nonflags[@]}"
}

# Parse a file for documented rules and functions
__bar_parse_file()
{
    local public_mode=false
    local module=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --public)
                public_mode=true
                shift
                ;;
            --module)
                module="$2"
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    local file="$1"

    [[ ! -f "$file" || ! -r "$file" ]] && return

    # If module not specified, extract from filename
    if [[ -z "$module" ]]; then
        # For files in Bar.d/, use the basename as module name
        if [[ "$file" == *"Bar.d/"* || "$file" == *"bar.d/"* ]]; then
            module=$(basename "$file")
        fi
    fi

    local in_doc_comment=false
    local doc_params=""
    local last_doc_line=""

    while IFS= read -r line; do
        # Check for prototype definition: # prototype: "name" = "completer_spec"
        # Must start at column 0 (no leading whitespace)
        if [[ "$line" =~ ^#[[:space:]]*prototype:[[:space:]]*\"([^\"]+)\"[[:space:]]*=[[:space:]]*\"([^\"]+)\"[[:space:]]*$ ]]; then
            local proto_name="${BASH_REMATCH[1]}"
            local completer_spec="${BASH_REMATCH[2]}"

            # Only register prototypes with module scope
            # Prototypes without module context are ignored to prevent overriding global prototypes
            if [[ -n "$module" ]]; then
                __bar_protoregistry["${module}@${proto_name}"]="$completer_spec"
            fi

        # Check for documented function: function name ## [params] - description
    elif [[ "$line" =~ ^function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*##[[:space:]]*(.*)$ ]]; then
            local func="${BASH_REMATCH[1]}"
            local doc="${BASH_REMATCH[2]}"
            __bar_functions+=("$func")

            # Track module for this function
            if [[ -n "$module" ]]; then
                __bar_func_module[$func]="$module"
            fi

            # Extract parameters from documentation
            # Format: [params] - description OR just description
            if [[ "$doc" =~ ^(.+)[[:space:]]+-[[:space:]] ]]; then
                local func_params="${BASH_REMATCH[1]}"
                __bar_func_params[$func]="$func_params"
            fi

            # Check if this is a module-specific completer (pattern: <module>_<proto>_complete)
            if [[ "$func" =~ ^([a-z][a-z0-9]*)_([a-z][a-z0-9]*)_complete$ ]]; then
                local mod="${BASH_REMATCH[1]}"
                local proto="${BASH_REMATCH[2]}"
                # Register in completion registry
                __bar_protoregistry["${mod}@${proto}"]="ext $func"
                # Store in module completers list (currently unused)
                # __bar_module_completers+=("${mod}:${func}")
            fi

            in_doc_comment=false
            doc_params=""

        # Check for function preceded by doc comment
    elif [[ $in_doc_comment == true && "$line" =~ ^function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*) ]]; then
            local func="${BASH_REMATCH[1]}"
            __bar_functions+=("$func")

            # Track module for this function
            if [[ -n "$module" ]]; then
                __bar_func_module[$func]="$module"
            fi

            # Store parameters if we captured them
            if [[ -n "$doc_params" ]]; then
                __bar_func_params[$func]="$doc_params"
            fi

            # Check if this is a module-specific completer (pattern: <module>_<proto>_complete)
            if [[ "$func" =~ ^([a-z][a-z0-9]*)_([a-z][a-z0-9]*)_complete$ ]]; then
                local mod="${BASH_REMATCH[1]}"
                local proto="${BASH_REMATCH[2]}"
                # Register in completion registry
                __bar_protoregistry["${mod}@${proto}"]="ext $func"
                # Store in module completers list (currently unused)
                # __bar_module_completers+=("${mod}:${func}")
            fi

            in_doc_comment=false
            doc_params=""

        # In public mode, also capture undocumented functions
    elif [[ $public_mode == true && "$line" =~ ^function[[:space:]]+([A-Za-z_][A-Za-z0-9_]*) ]]; then
            local func="${BASH_REMATCH[1]}"
            # Only add if not already added (documented ones are already in)
            local already_added=false
            for existing in "${__bar_functions[@]}"; do
                if [[ "$existing" == "$func" ]]; then
                    already_added=true
                    break
                fi
            done
            if [[ $already_added == false ]]; then
                __bar_functions+=("$func")
            fi

        # Check for documented rule: ## [params] - description followed by rule name:
        elif [[ "$line" =~ ^##[[:space:]]*(.*)$ ]]; then
            in_doc_comment=true
            last_doc_line="${BASH_REMATCH[1]}"
            # Check if this line has parameters; only record the first match
            if [[ -z "$doc_params" && "$last_doc_line" =~ ^(.+)[[:space:]]+-[[:space:]] ]]; then
                local param_part="${BASH_REMATCH[1]}"
                param_part="$(printf '%s' "$param_part" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
                doc_params="$param_part"
            fi
    elif [[ $in_doc_comment == true && "$line" =~ ^rule[[:space:]]+(--[a-z_-]*[[:space:]]+)*([A-Za-z_-][A-Za-z0-9_-]*): ]]; then
            local rule="${BASH_REMATCH[2]}"
            __bar_rules+=("$rule")

            # Track module for this rule
            if [[ -n "$module" ]]; then
                __bar_rule_module[$rule]="$module"
            fi

            # Store parameters if we captured them
            if [[ -n "$doc_params" ]]; then
                __bar_rule_params[$rule]="$doc_params"
            fi

            in_doc_comment=false
            doc_params=""
    elif [[ "$line" =~ ^rule[[:space:]]+(--[a-z_-]*[[:space:]]+)*([A-Za-z_-][A-Za-z0-9_-]*): ]]; then
            # In public mode, also capture undocumented rules
            if [[ $public_mode == true ]]; then
                local rule="${BASH_REMATCH[2]}"
                # Only add if not already added (documented ones are already in)
                local already_added=false
                for existing in "${__bar_rules[@]}"; do
                    if [[ "$existing" == "$rule" ]]; then
                        already_added=true
                        break
                    fi
                done
                if [[ $already_added == false ]]; then
                    __bar_rules+=("$rule")
                    # Track module for undocumented rules too
                    if [[ -n "$module" ]]; then
                        __bar_rule_module[$rule]="$module"
                    fi
                fi
            fi
            in_doc_comment=false
            doc_params=""
    elif [[ "$line" =~ ^rule[[:space:]] ]]; then
            in_doc_comment=false
            doc_params=""
        fi
    done < "$file"
}

# Scan for rule files and parse them
__bar_scan_files()
{
    local cmd="${1:-bar}"

    # Clear existing data
    __bar_rules=()
    __bar_functions=()
    # Use local variable for rulefiles tracking
    local -a rulefiles=()

    # Determine which files to look for
    local default_barfs=()
    if [[ "$cmd" == *please* ]]; then
        default_barfs=("Pleasef" "pleasef" ".Pleasef" ".pleasef" "$HOME/.Pleasef")
    else
        default_barfs=("Barf" "barf" ".Barf" ".barf")
    fi

    # Find the main rulefile
    local barf
    for barf in "${default_barfs[@]}"; do
        if [[ -f "$barf" && -r "$barf" ]]; then
            rulefiles+=("$barf")
            __bar_parse_file --public "$barf"
            break
        fi
    done

    # Add Bar.d modules if directory exists
    local bar_d_dirs=()
    if [[ "$cmd" == *please* ]]; then
        bar_d_dirs=("$HOME/.config/please")
    else
        # shellcheck disable=2155
        local prefix="$(command -v bar)"
        prefix="${prefix%/bin/*}"
        bar_d_dirs=("Bar.d" "bar.d" ".Bar.d" ".bar.d" "${prefix:+$prefix/share/bar/Bar.d}")
    fi

    for bar_d in "${bar_d_dirs[@]}"; do
        if [[ -d "$bar_d" ]]; then
            for module in "$bar_d"/*; do
                [[ -f "$module" && -r "$module" ]] || continue
                __bar_parse_file "$module"
            done
            break
        fi
    done
}

# Main completion function
_bar_complete()
{
    local cur cword
    local -a protos  # Dynamic array of prototype specs
    local proto_idx=0
    local -A cache=()   # Cache for current position completions
    local active_func_or_rule=""

    __bar_dbg "=== Bar completion triggered ==="

    # Initialize completion variables (works without bash-completion package)
    if type _bar_init_completion &>/dev/null; then
        _bar_init_completion || return
    else
        # Manual initialization
        cur="${COMP_WORDS[COMP_CWORD]}"
        cword=$COMP_CWORD
    fi

    # Ensure cur/cword populated when _init_completion is available
    local cur_input="${COMP_WORDS[COMP_CWORD]}"
    cur="$cur_input"
    cword=$COMP_CWORD

    local -a cache_signature_words=("${COMP_WORDS[@]}")
    cache_signature_words[cword]=""

    local cache_signature="$cword|"
    local cache_sig_part
    for cache_sig_part in "${cache_signature_words[@]}"; do
        cache_signature+="${cache_sig_part}"$'\037'
    done

    if type compopt >/dev/null 2>&1; then
        compopt -o nosort 2>/dev/null || true
    fi

    if [[ "$__bar_cache_signature" == "$cache_signature" && "$cur_input" == "${__bar_cache_prefix}"* ]]; then
        __bar_dbg "Using cached completions for signature: $cache_signature (prefix: $__bar_cache_prefix -> $cur_input)"
        local -a filtered_reply=()
        if [[ ${#__bar_cache[@]} -gt 0 ]]; then
            local cached_item
            for cached_item in "${__bar_cache[@]}"; do
                if [[ -z "$cur_input" || "$cached_item" == "$cur_input"* ]]; then
                    filtered_reply+=("$cached_item")
                fi
            done
        fi
        COMPREPLY=("${filtered_reply[@]}")
        __bar_cache_prefix="$cur_input"
        return 0
    fi

    __bar_cache=()
    COMPREPLY=()

    __bar_dbg "Command line: ${COMP_WORDS[*]}"
    __bar_dbg "Current word index: $cword"
    __bar_dbg "Current word: '$cur'"

    __bar_extcomp_command=""
    __bar_extcomp_command_index=-1

    # Determine the command (bar, please, or a path like ./bar)
    local cmd="${COMP_WORDS[0]}"
    __bar_invocation="$cmd"

    # For ./bar or similar, check if it's a bar executable
    if [[ "$cmd" == ./* || "$cmd" == ../* || "$cmd" == *"/bar" ]]; then
        # It's a path to bar
        if [[ ! -x "$cmd" ]]; then
            __bar_dbg "Command not executable: $cmd"
            return
        fi
    fi

    # Initialize completion registry if not done yet
    if [[ ${#__bar_protoregistry[@]} -eq 0 ]]; then
        __bar_dbg "Initializing completion registry..."
        __bar_init_completion_registry
    fi

    # Scan for files
    __bar_dbg "Scanning for files with command: $cmd"
    __bar_scan_files "$cmd"

    # Build initial protos array based on bar invocation syntax:
    # bar [rulefile] [--bare] [rule [arguments..]]
    # All are optional, so completion collects from all
    # Note: Everything in [] or <> is a prototype
    protos=("[rulefile]" "[--bare]" "[rule [arguments..]]")

    # Process previous words to determine current position
    local word_idx=1

    while [[ $word_idx -lt $cword ]]; do
        local word="${COMP_WORDS[$word_idx]}"
        __bar_dbg "Processing word[$word_idx]: '$word' at proto_idx=$proto_idx"

        # If we've run out of protos, stay at last known position
        if [[ $proto_idx -ge ${#protos[@]} ]]; then
            __bar_dbg "Beyond protos array, staying at last position"
            word_idx=$((word_idx + 1))
            continue
        fi

        # Try to match the word against current proto
        local matched=false
        local proto="${protos[$proto_idx]}"

        # Extract prototype name from proto spec (remove brackets)
        local proto_name="$proto"
        proto_name="${proto_name#[}"
        proto_name="${proto_name%]}"

        __bar_dbg "  Trying to match '$word' against proto '$proto_name'"

        # Check for nested prototypes like "[rule [arguments..]]"
        # For now, extract just the first part
        if [[ "$proto_name" =~ ^([a-zA-Z_-]+)[[:space:]] ]]; then
            local first_part="${BASH_REMATCH[1]}"
            __bar_dbg "  Nested proto detected, first part: $first_part"
        fi

        # Check if this matches a literal (supports alternation like [-s|--short])
        local -a proto_variants=("$proto_name")
        if [[ "$proto_name" == *'|'* ]]; then
            IFS='|' read -ra proto_variants <<< "$proto_name"
        fi

        local proto_variant
        for proto_variant in "${proto_variants[@]}"; do
            [[ -n "$proto_variant" ]] || continue

            # Direct literal equality (covers documented literals)
            if [[ "$word" == "$proto_variant" ]]; then
                matched=true
                __bar_dbg "  Matched literal variant: $proto_variant"
                proto_idx=$((proto_idx + 1))
                break
            fi

            # Try lookup via completion registry (handles literal prototypes declared elsewhere)
            local completer=""
            if [[ -v __bar_protoregistry["$proto_variant"] ]]; then
                completer="${__bar_protoregistry[$proto_variant]}"
            elif [[ -n "$active_func_or_rule" ]]; then
                completer=$(__bar_get_completer "$active_func_or_rule" "$proto_variant") || true
            fi

            if [[ -n "$completer" && "$completer" == "__bar_comp_literal "* ]]; then
                local literal="${completer#__bar_comp_literal }"
                if [[ "$literal" == "$word" ]]; then
                    matched=true
                    __bar_dbg "  Matched literal variant via completer: $proto_variant -> $literal"
                    proto_idx=$((proto_idx + 1))
                    break
                fi
            fi

            # Handle variants with literal prefix/suffix (e.g. +toolchain, rule:)
            local -a variant_parts
            mapfile -t variant_parts < <(_bar_extract_literal_punct "$proto_variant")
            local literal_prefix="${variant_parts[1]}"
            local literal_suffix="${variant_parts[2]}"

            if [[ -n "$literal_prefix" || -n "$literal_suffix" ]]; then
                local remaining="$word"

                if [[ -n "$literal_prefix" ]]; then
                    if [[ "$remaining" == "$literal_prefix"* ]]; then
                        remaining="${remaining#"$literal_prefix"}"
                    else
                        continue
                    fi
                fi

                if [[ -n "$literal_suffix" ]]; then
                    if [[ "$remaining" == *"$literal_suffix" ]]; then
                        remaining="${remaining%"$literal_suffix"}"
                    else
                        continue
                    fi
                fi

                # When both literals match, consider the prototype satisfied
                matched=true
                __bar_dbg "  Matched literal variant via punct: $proto_variant (${literal_prefix}_ ${literal_suffix})"
                proto_idx=$((proto_idx + 1))
                break
            fi
        done

        # If not matched yet, check for special prototype types
        if [[ $matched == false ]]; then
            if [[ "$proto_name" =~ ^rule[[:space:]] ]] || [[ "$proto_name" == "rule" ]]; then
                # This proto expects a rule - check if word is a known rule/function
                local is_rule=false
                for rule in "${__bar_rules[@]}"; do
                    if [[ "$rule" == "$word" ]]; then
                        is_rule=true
                        break
                    fi
                done
                if [[ $is_rule == false ]]; then
                    for func in "${__bar_functions[@]}"; do
                        if [[ "$func" == "$word" ]]; then
                            is_rule=true
                            break
                        fi
                    done
                fi

                if [[ $is_rule == true ]]; then
                    __bar_dbg "  Matched rule/function: $word"
                    active_func_or_rule="$word"

                    # Get parameter spec for this rule/function
                    local param_spec=""
                    if [[ -v __bar_rule_params["$word"] ]]; then
                        param_spec="${__bar_rule_params[$word]}"
                    elif [[ -v __bar_func_params["$word"] ]]; then
                        param_spec="${__bar_func_params[$word]}"
                    fi

                    if [[ -n "$param_spec" ]]; then
                        # Replace remaining protos with the rule's parameter spec
                        mapfile -t protos < <(_bar_parse_protos "$param_spec")
                        proto_idx=0
                    else
                        # No param spec - check if current proto has nested [arguments..]
                        if [[ "$proto_name" =~ \[arguments\.\.?\] ]]; then
                            # Promote to [arguments..]
                            protos=("[arguments..]")
                            proto_idx=0
                        else
                            # Clear protos (any arguments accepted)
                            protos=()
                            proto_idx=0
                        fi
                    fi
                    matched=true
                fi

                if [[ $matched == false && -n "$word" ]]; then
                    if __bar_extcomp_has_completion "$word"; then
                        __bar_dbg "  Delegating to external completion for command: $word"
                        __bar_extcomp_command="$word"
                        __bar_extcomp_command_index=$word_idx
                        active_func_or_rule="__extcomp::$word"
                        protos=("[commandargs..]")
                        proto_idx=0
                        matched=true
                    fi
                fi
            elif [[ "$proto_name" == "rulefile" ]]; then
                # Check if this word is a file
                if [[ -f "$word" ]]; then
                    __bar_dbg "  Matched rulefile: $word"
                    matched=true
                    proto_idx=$((proto_idx + 1))
                    # Action: parse this specific rulefile to discover its rules (with --public)
                    __bar_parse_file --public "$word"
                fi
            fi
        fi

        # If didn't match and proto is optional, skip it and try next
        if [[ $matched == false && "$proto" == "["* ]]; then
            __bar_dbg "  Didn't match, skipping optional proto: $proto"
            proto_idx=$((proto_idx + 1))
            continue  # Don't increment word_idx, try same word against next proto
        elif [[ $matched == false ]]; then
            # Required proto didn't match or unknown - move on
            __bar_dbg "  Didn't match required proto, advancing anyway"
            proto_idx=$((proto_idx + 1))
        fi

        word_idx=$((word_idx + 1))
    done

    # Now generate completions based on current proto_idx
    # Collect completions from current proto and all following optional protos
    # until we hit a non-optional proto

    __bar_dbg "Generating completions starting at proto_idx=$proto_idx"

    local -a all_completions=()
    local check_idx=$proto_idx

    while [[ $check_idx -lt ${#protos[@]} ]]; do
        local proto="${protos[$check_idx]}"

        # If empty or we've exhausted protos, stop
        [[ -z "$proto" ]] && break

        # Check if this proto is optional
        local is_optional=false
        [[ "$proto" =~ ^\[ ]] && is_optional=true

        __bar_dbg "  Checking proto[$check_idx]: '$proto' (optional=$is_optional)"

        # Use _bar_expand_group_alternatives to properly handle nested groups
        local -a expanded_alternatives=()
        mapfile -t expanded_alternatives < <(_bar_expand_group_alternatives "$proto")

        __bar_dbg "  Expanded to ${#expanded_alternatives[@]} alternatives: ${expanded_alternatives[*]}"

        local completions_before=${#all_completions[@]}
        local have_variant_completer=false

        local proto_variant
        for proto_variant in "${expanded_alternatives[@]}"; do
            [[ -z "$proto_variant" ]] && continue

            # Remove trailing .. if present (repetition marker)
            proto_variant="${proto_variant%..\$}"
            proto_variant="${proto_variant%..}"

            # Extract literal punctuation so lookups ignore prefix/suffix per variant
            local -a punct_parts
            mapfile -t punct_parts < <(_bar_extract_literal_punct "$proto_variant")
            local proto_clean="${punct_parts[0]}"
            local literal_prefix="${punct_parts[1]}"
            local literal_suffix="${punct_parts[2]}"

            # Get completer for this prototype from registry with module context
            local completer
            completer=$(__bar_get_completer "$active_func_or_rule" "$proto_clean") || true

            if [[ -z "$completer" ]]; then
                __bar_dbg "  No completer found for variant '$proto_clean'"
                continue
            fi

            have_variant_completer=true
            __bar_dbg "  Found completer for '$proto_clean': $completer"

            # Decide which prefix to pass to the completer. When the literal prefix/suffix
            # has not been typed yet, request the full result set so we can add literals
            # ourselves before filtering.
            local cur_for_completer
            if [[ -n "$literal_prefix" ]]; then
                if [[ "$cur" == "$literal_prefix"* ]]; then
                    cur_for_completer="$cur"
                else
                    cur_for_completer="${literal_prefix}${cur}"
                fi
            else
                cur_for_completer="$cur"
            fi

            # Cache key combines completer, request prefix, literals, and current word
            local completer_cache_key="${completer}::${cur_for_completer}::${literal_prefix}::${literal_suffix}::${cur}"

            if [[ -v cache["$completer_cache_key"] ]]; then
                __bar_dbg "  Using cached results for $completer_cache_key"
                local cached_results="${cache[$completer_cache_key]}"
                if [[ -n "$cached_results" ]]; then
                    local -a cached_comps=()
                    mapfile -t cached_comps <<< "$cached_results"
                    all_completions+=("${cached_comps[@]}")
                fi
                continue
            fi

            local -a new_comps=()

            if [[ "$completer" == "__bar_comp_ext "* ]]; then
                local ext_name="${completer#__bar_comp_ext }"
                while IFS= read -r comp; do
                    [[ -z "$comp" ]] && continue
                    local adjusted
                    adjusted=$(__bar_apply_literals "$comp" "$literal_prefix" "$literal_suffix")
                    if [[ -z "$cur" || "$adjusted" == "$cur"* ]]; then
                        new_comps+=("$adjusted")
                        all_completions+=("$adjusted")
                        __bar_dbg "     adding completion: $adjusted"
                    fi
                done < <(__bar_comp_ext "$ext_name" "$cur_for_completer")
            elif [[ "$completer" == "__bar_comp_extcomp "* ]]; then
                local ext_cmd="${completer#__bar_comp_extcomp }"
                while IFS= read -r comp; do
                    [[ -z "$comp" ]] && continue
                    local adjusted
                    adjusted=$(__bar_apply_literals "$comp" "$literal_prefix" "$literal_suffix")
                    if [[ -z "$cur" || "$adjusted" == "$cur"* ]]; then
                        new_comps+=("$adjusted")
                        all_completions+=("$adjusted")
                        __bar_dbg "     adding completion: $adjusted"
                    fi
                done < <(__bar_comp_extcomp "$ext_cmd" "$cur_for_completer")
            elif [[ "$completer" == "__bar_comp_literal "* ]]; then
                local literal="${completer#__bar_comp_literal }"
                local adjusted
                adjusted=$(__bar_apply_literals "$literal" "$literal_prefix" "$literal_suffix")
                if [[ -z "$cur" || "$adjusted" == "$cur"* ]]; then
                    new_comps+=("$adjusted")
                    all_completions+=("$adjusted")
                    __bar_dbg "     adding completion: $adjusted"
                fi
            else
                local -a completer_parts
                read -ra completer_parts <<< "$completer"
                local comp_func="${completer_parts[0]}"
                local -a comp_args=("${completer_parts[@]:1}")

                while IFS= read -r comp; do
                    [[ -z "$comp" ]] && continue
                    local adjusted
                    adjusted=$(__bar_apply_literals "$comp" "$literal_prefix" "$literal_suffix")
                    if [[ -z "$cur" || "$adjusted" == "$cur"* ]]; then
                        new_comps+=("$adjusted")
                        all_completions+=("$adjusted")
                        __bar_dbg "     adding completion: $adjusted"
                    fi
                done < <("$comp_func" "$cur_for_completer" "${comp_args[@]}")
            fi

            if [[ ${#new_comps[@]} -gt 0 ]]; then
                cache["$completer_cache_key"]="$(printf '%s\n' "${new_comps[@]}")"
            else
                cache["$completer_cache_key"]=""
            fi
        done

        if [[ $have_variant_completer == false ]]; then
            __bar_dbg "  No completer found for '$proto_name', using file completion"
            while IFS= read -r comp; do
                [[ -z "$comp" ]] && continue
                all_completions+=("$comp")
            done < <(__bar_comp_file "$cur")
        elif (( ${#all_completions[@]} == completions_before )); then
            __bar_dbg "  Completer for '$proto_name' returned no results"
        fi

        # If this proto is not optional, stop collecting
        if [[ $is_optional == false ]]; then
            break
        fi

        check_idx=$((check_idx + 1))
    done

    # Return the collected completions
    if [[ ${#all_completions[@]} -gt 0 ]]; then
        mapfile -t COMPREPLY < <(__bar_finalize_completions "${all_completions[@]}")
    fi

    __bar_cache=("${COMPREPLY[@]}")
    __bar_cache_signature="$cache_signature"
    __bar_cache_prefix="$cur_input"

    return 0
}

# Register completion for bar and please
complete -o nosort -F _bar_complete bar
complete -o nosort -F _bar_complete please

# Also register for ./bar pattern (when bar is in current directory)
# This won't work perfectly for all cases, but handles the common ./bar case
if [[ -x ./bar ]]; then
    complete -o nosort -F _bar_complete ./bar
fi
